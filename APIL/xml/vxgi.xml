<?xml version="1.0" encoding="UTF-8"?>
<namespace name="VXGI">
	<struct name="Version">
		<var>
			<type>uint32_t</type>
			<name>Major</name>
		</var>
		<var>
			<type>uint32_t</type>
			<name>Minor</name>
		</var>
		<var>
			<type>uint32_t</type>
			<name>Branch</name>
		</var>
		<var>
			<type>uint32_t</type>
			<name>Revision</name>
		</var>


		<default>
			<li>Major(0)</li>
			<li>Minor(9)</li>
			<li>Branch(0)</li>
			<li>Revision(19557187)</li>
		</default>
	</struct>

	<struct name="Status">
		<enum name="Enum">
			<li>OK = 0</li>
			<li>WRONG_INTERFACE_VERSION = 1</li>
			<li>D3D_COMPILER_UNAVAILABLE</li>
			<li>INSUFFICIENT_BINDING_SLOTS</li>
			<li>INTERNAL_ERROR</li>
			<li>INVALID_ARGUMENT</li>
			<li>INVALID_CONFIGURATION</li>
			<li>INVALID_SHADER_BINARY</li>
			<li>INVALID_SHADER_SOURCE</li>
			<li>INVALID_STATE</li>
			<li>NULL_ARGUMENT</li>
			<li>RESOURCE_CREATION_FAILED</li>
			<li>SHADER_COMPILATION_ERROR</li>
			<li>SHADER_MISSING</li>
			<li>BUFFER_TOO_SMALL</li>
			<li>NOT_SUPPORTED</li>
		</enum>
	</struct>

	<struct name="EmittanceDirections">
		<enum name="Enum">
			<li>NONE = 0</li>
			<li>THREE_DIMENSIONAL = 3</li>
			<li>SIX_DIMENSIONAL = 6</li>
		</enum>
	</struct>

	<struct name="OpacityDirections">
		<enum name="Enum">
			<li>THREE_DIMENSIONAL = 3</li>
			<li>SIX_DIMENSIONAL = 6</li>
		</enum>
	</struct>

	<struct name="EmittanceFormat">
		<enum name="Enum">
			<li>PERFORMANCE = 0 <comment type="default">use FLOAT16 if it is supported, UNORM8 otherwise</comment></li>
			<li>QUALITY = 1 <comment type="default">use FLOAT16 if it is supported, FLOAT32 otherwise</comment></li>
			<li>UNORM8 = 2<comment type="default">use RGBA8_UNORM_SRGB - lowest quality mode</comment></li>
			<li>FLOAT16 = 3<comment type="default">use RGBA16_FLOAT; only supported on Maxwell [*] GPUs when enableNvidiaExtensions == true</comment></li>
			<li>FLOAT32 = 4<comment type="default">use 3x R32_FLOAT textures</comment></li>
		</enum>
	</struct>

	<struct name="MultiBounceMode">
		<enum name="Enum">
			<li>DISABLED = 0</li>
			<li>LOW_QUALITY = 1<comment type="default">trace up to 6 cones for each irradiance voxel</comment></li>
			<li>HIGH_QUALITY = 2<comment type="default">trace up to 14 cones for each irradiance voxel</comment></li>
		</enum>
	</struct>

	<struct name="DebugRenderMode">
		<enum name="Enum">
			<li>DISABLED = 0</li>
			<li>ALLOCATION_MAP</li>
			<li>OPACITY_TEXTURE</li>
			<li>EMITTANCE_TEXTURE</li>
			<li>IRRADIANCE_TEXTURE</li>
		</enum>
	</struct>

	<struct name="APISpecificInterface">
		<enum name="Enum">
			<li>D3D11DEVICE</li>
			<li>D3D11DEVICECONTEXT</li>
			<li>WIN32_HGLRC</li>
			<li>EGLDISPLAY</li>
			<li>EGLSURFACE</li>
			<li>EGLCONTEXT</li>
		</enum>
	</struct>

	<struct name="PrimitiveType">
		<enum name="Enum">
			<li>POINT_LIST</li>
			<li>TRIANGLE_LIST</li>
			<li>TRIANGLE_STRIP</li>
		</enum>
	</struct>

	<struct name="CommonTracingParameters">
		<var>
			<type>uint32_t</type>
			<name>maxSamples</name>
			<comment type="default">Maximum number of samples that can be fetched for each cone.</comment>
		</var>
		<var>
			<type>float</type>
			<name>tracingStep</name>
			<comment type="default">Tracing step.Reasonable values [0.5, 1]. Sampling with lower step produces more stable results at Performance cost.</comment>
		</var>
		<var>
			<type>float</type>
			<name>opacityCorrectionFactor</name>
			<comment type="default">Opacity correction factor.Reasonable values [0.1, 10]. Higher values produce more contrast rendering, overall picture looks darker.</comment>
		</var>
		<var>
			<type>float</type>
			<name>irradianceScale</name>
			<comment type="default">Multiplier for the incoming light intensity.</comment>
		</var>
		<var>
			<type>bool</type>
			<name>flipOpacityDirections</name>
			<comment type="default">Flips the direction in which geometry blocks light - sometimes it helps improve occlusion quality, for example it reduces "peter panning" of objects in specular reflections.</comment>
		</var>
		<var>
			<type>Vector4f</type>
			<name>debugParameters</name>
			<comment type="default">These should be set to zero and normally have no effect</comment>
		</var>

		<comment type="default">Projection parameters: near and far clip planes' post-projection Z values</comment>
		<var>
			<type>float</type>
			<name>nearClipZ</name>
			<comment type="default">0.0 for regular projections</comment>
		</var>
		<var>
			<type>float</type>
			<name>farClipZ</name>
			<comment type="default">1.0 for regular projections</comment>
		</var>
		<default>
			<li>maxSamples(128)</li>
			<li>tracingStep(1.0f)</li>
			<li>opacityCorrectionFactor(1.0f)</li>
			<li>irradianceScale(1.0f)</li>
			<li>flipOpacityDirections(false)</li>
			<li>debugParameters(0.0f)</li>
			<li>nearClipZ(0.0f)</li>
			<li>farClipZ(1.0f)</li>
		</default>
	</struct>

	<struct name="DiffuseTracingParameters" public="CommonTracingParameters">
		<var>
			<type>uint32_t</type>
			<name>numCones</name>
			<comment type="default">Number of diffuse cones to trace for each fragment, 4 or more. Balances Quality (more cones) vs Performance.</comment>
		</var>
		<var>
			<type>bool</type>
			<name>autoConeAngle</name>
			<comment type="default">Automatic diffuse angle computation based on the number of cones.Overrides the value set in coneAngle. Use IViewTracer::getDiffuseConeAngle(numCones) to get the actual diffuse angle.</comment>
		</var>
		<var>
			<type>float</type>
			<name>coneAngle</name>
			<comment type="default">Cone angle for GI diffuse component evaluation, in degrees.This value has no effect if autoConeAngle == true.</comment>
		</var>
		<var>
			<type>Vector3f</type>
			<name>ambientColors[6]</name>
			<comment type="default">Optional colors for adding occluded directional ambient lighting. Directions are ordered as follows: X+, X-, Y+, Y-, Z+, Z-. The ambient component is added to the diffuse channel, and is NOT multiplied by irradianceScale. To get a normalized ambient occlusion only rendering, set all ambientColors to 1.0 and irradianceScale to 0. Note: in ambient occlusion mode, i.e. when VoxelizationParameters::emittanceDirectionCount == NONE, only ambientColors[0] is used.</comment>
		</var>
		<var>
			<type>float</type>
			<name>ambientRange</name>
			<comment type="default">World-space distance at which the contribution of geometry to ambient occlusion will be 10x smaller than near the surface.</comment>
		</var>
		<var>
			<type>bool</type>
			<name>enableConeRotation</name>
			<comment type="default">Random per-pixel rotation of the diffuse cone set - it helps reduce banding but costs some performance.</comment>
		</var>
		<var>
			<type>bool</type>
			<name>enableRandomConeOffsets</name>
			<comment type="default">Random per-pixel adjustment of initial tracing offsets for diffuse tracing, also helps reduce banding.</comment>
		</var>
		<var>
			<type>bool</type>
			<name>enableRandomConeOffsets</name>
			<comment type="default">Random per-pixel adjustment of initial tracing offsets for diffuse tracing, also helps reduce banding.</comment>
		</var>
		<var>
			<type>float</type>
			<name>normalOffsetFactor</name>
			<comment type="default">A factor that controls linear interpolation between smoothNormal and ray direction. The interpolated value is used to direct the initial cone offset. Accepted values are [0, 1].</comment>
		</var>
		<var>
			<type>uint32_t</type>
			<name>tracingSparsity</name>
			<comment type="default">Diffuse tracing sparsity. 1 = dense tracing (for every pixel), 2..4 = sparse tracing (for one pixel in every NxN square).  Using sparse tracing greatly improves performance in exchange for fine detail quality.</comment>
		</var>
		<var>
			<type>float</type>
			<name>coneNormalGroupingFactor</name>
			<comment type="default">Bigger factor would move the diffuse cones closer to the surface normal. Reasonable values [0, 1]</comment>
		</var>
		<comment type="default">Parameters that control the distance of the first sample from the surface.</comment>
		<var>
			<type>float</type>
			<name>initialOffsetBias</name>
		</var>		
		<var>
			<type>float</type>
			<name> initialOffsetDistanceFactor</name>
		</var>
		<var>
			<type>bool</type>
			<name>enableScreenSpaceCorrection</name>
			<comment type="default">Enables screen space diffuse tracing correction.</comment>
		</var>
		<comment type="default">Adaptive diffuse tracing parameters - experimental.</comment>
		<var>
			<type>float</type>
			<name>adaptiveSplatRadiusFactor</name>
		</var>
		<var>
			<type>float</type>
			<name>adaptiveDensityFactor</name>
		</var>
		<var>
			<type>bool</type>
			<name>enableTemporalReprojection</name>
			<comment type="default">Enables reuse of diffuse tracing results from the previous frame. For this mode to work, different G-buffer textures have to be used for consecutive frames, at least the depth and normal channels. Otherwise the tracing calls will fail.</comment>
		</var>
		<var>
			<type>float</type>
			<name>temporalReprojectionWeight</name>
			<comment type="default">Weight of the reprojected irradiance data relative to newly computed data, (0..1), where 0 means do not use reprojection, and values closer to 1 mean accumulate data over more previous frames. Higher values result in better filtering of random rotation/offset noise, but also introduce a lag of GI from moving objects. 1.0 or higher will produce an unstable result.</comment>
		</var>
		<var>
			<type>float</type>
			<name>temporalReprojectionMaxDistanceInVoxels</name>
			<comment type="default">Maximum distance between two samples for which they're still considered to be the same surface, expressed in voxels.</comment>
		</var>
		<var>
			<type>float</type>
			<name>temporalReprojectionNormalWeightExponent</name>
			<comment type="default">The exponent used for the dot product of old and new normals in the temporal reprojection filter.</comment>
		</var>
		<default>
			<li>numCones(8)</li>
			<li>autoConeAngle(true)</li>
			<li>coneAngle(60.0f)</li>
			<li>ambientRange(512.0f)</li>
			<li>enableConeRotation(false)</li>
			<li>enableRandomConeOffsets(false)</li>
			<li>normalOffsetFactor(0.5f)</li>
			<li>tracingSparsity(2)</li>
			<li>coneNormalGroupingFactor(0.0f)</li>
			<li>initialOffsetBias(1.5f)</li>
			<li>initialOffsetDistanceFactor(1.5f)</li>
			<li>enableScreenSpaceCorrection(false)</li>
			<li>adaptiveSplatRadiusFactor(2.5f)</li>
			<li>adaptiveDensityFactor(1.0f)</li>
			<li>enableTemporalReprojection(false)</li>
			<li>temporalReprojectionWeight(0.9f)</li>
			<li>temporalReprojectionMaxDistanceInVoxels(0.25f)</li>
			<li>temporalReprojectionNormalWeightExponent(20.f)</li>
			<li>ambientColors[n] = Vector4f(1.0f);</li>
			<li>tracingStep = 0.5f</li>
		</default>
	</struct>

	<struct name="SpecularTracingParameters" public="CommonTracingParameters">
		<enum name="Filter">
			<li>FILTER_NONE</li>
			<li>FILTER_TEMPORAL</li>
			<li>FILTER_SIMPLE</li>
			<li>FILTER_EDGE</li>
		</enum>
		<var>
			<type>Filter</type>
			<name>filter</name>
			<comment type="default">Selects the filter that is used on the specular surface after tracing in order to reduce noise introduced by cone jitter. When filter == FILTER_NONE, jitter is not used.</comment>
		</var>
		<comment type="default">Parameters that control the distance of the first specular cone sample from the surface.</comment>
		<var>
			<type>float</type>
			<name>initialOffsetBias</name>
		</var>
		<var>
			<type>float</type>
			<name>initialOffsetDistanceFactor</name>
		</var>
		<var>
			<type>float</type>
			<name>environmentMapScale</name>
			<comment type="default">Multiplier for environment map reflections in the specular channel. The environment map will only be visible on pixels that do not reflect any solid geometry.</comment>
		</var>
		<var>
			<type>float</type>
			<name>enableScreenSpaceCorrection</name>
			<comment type="default">Enables screen space specular tracing correction.</comment>
		</var>
		<var>
			<type>float</type>
			<name>temporalReprojectionWeight</name>
			<comment type="default">Weight of the reprojected irradiance data relative to newly computed data, [0..1). Only applicable if filter == FILTER_TEMPORAL. Also see the comment for DiffuseTracingParameters::enableTemporalReprojection and temporalReprojectionWeight.</comment>
		</var>
		<var>
			<type>float</type>
			<name>temporalReprojectionMaxDistanceInVoxels</name>
			<comment type="default">Maximum distance between two samples for which they're still considered to be the same surface, expressed in voxels.</comment>
		</var>
		<var>
			<type>float</type>
			<name>temporalReprojectionNormalWeightExponent</name>
			<comment type="default">The exponent used for the dot product of old and new normals in the temporal reprojection filter.</comment>
		</var>
		<var>
			<type>float</type>
			<name>tangentJitterScale</name>
			<comment type="default">Scale of the jitter can be added to specular sample positions to reduce blockiness of the reflections, [0..1]. When filter == FILTER_TEMPORAL, the noise pattern is different on every frame.</comment>
		</var>
		<default>
			<li>filter(FILTER_SIMPLE)</li>
			<li>initialOffsetBias(1.5f)</li>
			<li>initialOffsetDistanceFactor(1.5f)</li>
			<li>environmentMapScale(0.0f)</li>
			<li>enableScreenSpaceCorrection(false)</li>
			<li>temporalReprojectionWeight(0.8f)</li>
			<li>tangentJitterScale(0.0f)</li>
			<li>temporalReprojectionMaxDistanceInVoxels(0.25f)</li>
			<li>temporalReprojectionNormalWeightExponent(20.f)</li>
		</default>
	</struct>

	<struct name="TracerVisionParameters" public="CommonTracingParameters">
		<var>
			<type>float</type>
			<name>coneAngle</name>
			<comment type="default">Cone angle for the Tracer Vision debug mode.</comment>
		</var>
		<default>
			<li>coneAngle(1.0f)</li>
		</default>
	</struct>

	<struct name="IrradianceMapTracingParameters" public="CommonTracingParameters">
		<var>
			<type>float</type>
			<name>coneAngle</name>
			<comment type="default">Cone angle for the Tracer Vision debug mode.</comment>
		</var>
		<default>
			<li>coneAngle(40.0f)</li>
		</default>
	</struct>


	<struct name="VoxelizationParameters" public="CommonTracingParameters">
		<var>
			<type>uint32_t</type>
			<name>mapSize</name>
			<comment type="default">Controls voxelization density, must be a power of 2 and within range [16, 256].</comment>
		</var>
		<var>
			<type>uint32_t</type>
			<name>allocationMapLodBias</name>
			<comment type="default">Controls allocation granularity, bigger values result in coarser allocation map being used.</comment>
		</var>
		<var>
			<type>uint32_t</type>
			<name>stackLevels</name>
			<comment type="default">Number of levels in a clipmap stack used for scene representation. Reasonable values [2, log2(MapSize) - 1].</comment>
		</var>
		<var>
			<type>OpacityDirections::Enum</type>
			<name>opacityDirectionCount</name>
			<comment type="default">The number of opacity directions stored per voxel.</comment>
		</var>
		<var>
			<type>EmittanceDirections::Enum</type>
			<name>emittanceDirectionCount</name>
			<comment type="default">The number of emittance directions to use for light injection and cone tracing.</comment>
		</var>
		<var>
			<type>bool</type>
			<name>enableNvidiaExtensions</name>
			<comment type="default">Controls whether the library should try to use NVIDIA-specific hardware features.</comment>
		</var>
		<var>
			<type>EmittanceFormat::Enum</type>
			<name>emittanceFormat</name>
			<comment type="default">Controls the format of the textures used to store emittance.</comment>
		</var>
		<var>
			<type>float</type>
			<name>emittanceStorageScale</name>
			<comment type="default">Global multiplier for emittance voxels - adjust it according to your light intensities to avoid clamping or quantization. As long as neither of these effects takes place, changing this parameter has no effect on rendered images.</comment>
		</var>
		<var>
			<type>int</type>
			<name>maxScatterIterations</name>
			<comment type="default">Number of iterations to handle scatter light injection. In RGBA8 emittance mode, a separate 3D texture is created for scatter light injection, and that texture requires a lot of memory. This parameter is essentially the divisor for that amount of memory. If maxScatterIterations == 0, scatter light injection is disabled and the texture is not created. In FP16 emittance mode, scatter light injection doesn't need a separate texture and always makes 1 iteration.</comment>
		</var>
		<var>
			<type>bool</type>
			<name>useEmittanceInterpolation</name>
			<comment type="default">Enables a mode wherein transitions from downsampled to directly voxelized emittance are smoothed by blending the two with a factor that depends on the exact clipmap anchor, not the quantized clipmap center. This mode is incompatible with scatter light injection (enabling both will produce an error) and it requires full emittance clipmap invalidates on every frame or anchor movement to operate properly.</comment>
		</var>	
		<var>
			<type>bool</type>
			<name>useHighQualityEmittanceDownsampling</name>
			<comment type="default">Enables a higher-order filter to be used during emittance downsampling. Using this filter makes moving objects produce much smoother indirect illumination, at a significant performance cost.</comment>
		</var>
		<var>
			<type>MultiBounceMode::Enum</type>
			<name>multiBounceMode</name>
			<comment type="default">Controls the quality of multi-bounce tracing, which is performed by computing a separate irradiance 3D map and using it on the next frame. In order to see multi-bounce lighting, call this function in the emittance voxelization pixel shader: float3 VXGI::GetIrradiance(float3 worldPos, float3 normal). Then shade the material with the returned irradiance (don't forget to divide it by PI) and add the result to output color.</comment>
		</var>	
		<var>
			<type>int32_t</type>
			<name>irradianceMapLodBias</name>
			<comment type="default">Controls the size of the irradiance map. If irradianceMapLodBias == 0 means that the irradiance map will have the same size and resolution as the coarsest clipmap level. If irradianceMapLodBias &gt; 0 means that there will be fewer voxels, but not fewer than in the allocation map. If irradianceMapLodBias &lt; 0 means that there will be more voxels, but not more than 256^3, and the resolution  will not be finer than the finest clipmap level.</comment>
		</var>
		<default>
			<li>mapSize(64)</li>
			<li>allocationMapLodBias(0)</li>
			<li>stackLevels(5)</li>
			<li>mipLevels(5)</li>
			<li>opacityDirectionCount(OpacityDirections::SIX_DIMENSIONAL)</li>
			<li>emittanceDirectionCount(EmittanceDirections::SIX_DIMENSIONAL)</li>
			<li>enableNvidiaExtensions(true)</li>
			<li>emittanceFormat(EmittanceFormat::PERFORMANCE)</li>
			<li>emittanceStorageScale(1.0f)</li>
			<li>maxScatterIterations(4)</li>
			<li>useEmittanceInterpolation(false)</li>
			<li>useHighQualityEmittanceDownsampling(false)</li>
			<li>multiBounceMode(MultiBounceMode::DISABLED)</li>
			<li>irradianceMapLodBias(0)</li>
		</default>						
	</struct>

	<struct name="TracedSamplesParameters">
		<enum name="ColorMode">
			<li>COLOR_MIP_LEVEL = 0</li>
			<li>COLOR_EMITTANCE = 1</li>
			<li>COLOR_OCCLUSION = 2</li>
			<li>COLOR_TEXELS_LOWER_MIP = 3</li>
			<li>COLOR_TEXELS_UPPER_MIP = 4</li>
		</enum>
		<var>
			<type>ColorMode</type>
			<name>colorMode</name>
		</var>
		<var>
			<type>bool</type>
			<name>onlyContributingSamples</name>
		</var>
		<var>
			<type>int32_t</type>
			<name>coneIndexFilter</name>
		</var>
		<var>
			<type>int32_t</type>
			<name>sampleIndexFilter</name>
		</var>
		<var>
			<type>bool</type>
			<name>showConeDirections</name>
		</var>
		<default>
			<li>onlyContributingSamples(false)</li>
			<li>coneIndexFilter(0)</li>
			<li>sampleIndexFilter(0)</li>
			<li>showConeDirections(false)</li>
			<li>colorMode(COLOR_MIP_LEVEL)</li>
		</default>
	</struct>

	<class name="IUserDefinedShaderSet" ></class>

	<struct name="MaterialInfo">
		<var>
			<type>IUserDefinedShaderSet*</type>
			<name>pixelShader</name>
		</var>
		<var>
			<type>IUserDefinedShaderSet*</type>
			<name>geometryShader</name>
		</var>
		<var>
			<type>float</type>
			<name>voxelizationThickness</name>
			<comment type="default">Opacity voxelization thickness in voxels. [0..2].</comment>
		</var>
		<comment type="default">Opacity voxelization anti-aliasing through jitter. Individual samples covered by objects are moved along the voxelization Z axis in order to smoothen the opacity transitions as objects move.</comment>
		<var>
			<type>float</type>
			<name>opacityNoiseScale</name>
			<comment type="default">in voxels, [-1..1]</comment>
		</var>
		<var>
			<type>float</type>
			<name>opacityNoiseBias</name>
			<comment type="default">in voxels, [-0.5..0.5]</comment>
		</var>
		<var>
			<type>bool</type>
			<name>twoSided</name>
			<comment type="default">Controls whether signed opacity representation of this object should block light in all directions, not just in front-to-back direction.</comment>
		</var>
		<var>
			<type>bool</type>
			<name>frontCounterClockwise</name>
			<comment type="default">Set this to true if the geometry is represented in FrontCCW mode.</comment>
		</var>
		<var>
			<type>bool</type>
			<name>proportionalEmittance</name>
			<comment type="default">Emittance voxelization anti-aliasing through a triangular filter applied in voxelization Z direction. This filter is almost free in terms of performance, but it makes directly voxelized emittance differ from downsampled emittance. For that reason, this filter should be used mostly on large dynamic objects.</comment>
		</var>
		<var>
			<type>bool</type>
			<name>omnidirectionalLight</name>
			<comment type="default">Controls whether light emitted by this material is omnidirectional. Set this to true for small objects.</comment>
		</var>
		<var>
			<type>int</type>
			<name>emittanceResolutionFactor</name>
			<comment type="default">A multiplier for emittance rasterization resolution, [1..4]. It's useful to set it to values higher than 1 in case shading results cannot be filtered well enough with once-per-voxel shading, i.e. when shading supersampling is necessary.</comment>
		</var>
		<default>
			<li>pixelShader(NULL)</li>
			<li>geometryShader(NULL)</li>
			<li>voxelizationThickness(1.0f)</li>
			<li>opacityNoiseScale(0.0f)</li>
			<li>opacityNoiseBias(0.0f)</li>
			<li>twoSided(false)</li>
			<li>frontCounterClockwise(false)</li>
			<li>proportionalEmittance(false)</li>
			<li>omnidirectionalLight(false)</li>
			<li>emittanceResolutionFactor(1)</li>
		</default>
	</struct>
	<struct name="LightDesc">
		<var>
			<type>LightHandle</type>
			<name>handle</name>
			<comment type="default">Something that identifies the light; it shouldn't change between frames for the same light.</comment>
		</var>
		<comment type="default">Matrices for the light.</comment>
		<var>
			<type>Matrix4f</type>
			<name>viewMatrix</name>
		</var>
		<var>
			<type>Matrix4f</type>
			<name>projMatrix</name>
		</var>
		<comment type="default">RSM textures, either all three are required or all three can be NULL in case light voxelization is used.</comment>
		<var>
			<type>TextureHandle</type>
			<name>depthTex</name>
		</var>
		<var>
			<type>TextureHandle</type>
			<name>emittanceTex</name>
		</var>
		<var>
			<type>TextureHandle</type>
			<name>normalTex</name>
		</var>
		<var>
			<type>uint32_t</type>
			<name>arrayIndex</name>
		</var>
		<comment type="default">Scaling and biasing for decoding the contents of normalTex. The effective normal is computed like this: N = normalTex.xyz * normalScale + normalBias.</comment>
		<var>
			<type>float</type>
			<name>normalScale</name>
		</var>
		<var>
			<type>float</type>
			<name>normalBias</name>
		</var>
		<var>
			<type>Vector3f</type>
			<name>emittanceScale</name>
			<comment type="default">A multiplier for colors in emittanceTex, useful when the light e.g. flickers but nothing else changes: no need to update the RSM in that case and emittanceScale == 0.0 disables injection for this light.</comment>
		</var>
		<var>
			<type>Box3f</type>
			<name>invalidationRegion</name>
			<comment type="default">A box in clip space that identifies the region inside the light frustum that has to be re-injected because something has changed inside that region.</comment>
		</var>
		<var>
			<type>bool</type>
			<name>useInvalidationRegion</name>
			<comment type="default">If useInvalidatedRegion == false, the whole light frustum is assumed to be invalidated. To tell VXGI that the light has not changed since the previous frame, set useInvalidationRegion = true with an empty invalidationRegion.</comment>
		</var>
		<comment type="default">RSM texel jitter parameters, in voxels. Every texel is moved along its normal by a pseudo-random offset to reduce surface quantization.</comment>
		<var>
			<type>float</type>
			<name>noiseScale</name>
		</var>	
		<var>
			<type>float</type>
			<name>noiseBias</name>
		</var>
		<default>
			<li>depthTex(NULL)</li>
			<li>emittanceTex(NULL)</li>
			<li>normalTex(NULL)</li>
			<li>arrayIndex(0)</li>
			<li>normalScale(1.0f)</li>
			<li>normalBias(0.0f)</li>
			<li>emittanceScale(1.0f)</li>
			<li>invalidationRegion()</li>
			<li>useInvalidationRegion(false)</li>
			<li>noiseScale(1.0f)</li>
			<li>noiseBias(-0.5f)</li>
		</default>	
	</struct>

	<class name="IRendererInterface" >
		<comment type="default">A class implementing interface ISceneRenderer should be implemented by the application. It provides a callback interface to the scene to the GI library.</comment>
		<func>
			<type>virtual TextureHandle</type>
			<name>createTexture</name>
			<parameters>
				<var>
					<type>const TextureDesc &amp;</type>
					<name>d</name>
				</var>
				<var>
					<type>const void*</type>
					<name>data</name>
				</var>
			</parameters>
		</func>

		<func>
			<type>virtual TextureDesc</type>
			<name>describeTexture</name>
			<parameters>
				<var>
					<type>TextureHandle</type>
					<name>t</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>clearTextureFloat</name>
			<parameters>
				<var>
					<type>TextureHandle</type>
					<name>t</name>
				</var>
				<var>
					<type>const Vector4f&amp;</type>
					<name>clearColor</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>clearTextureUInt</name>
			<parameters>
				<var>
					<type>TextureHandle</type>
					<name>t</name>
				</var>
				<var>
					<type>const Vector4f&amp;</type>
					<name>clearColor</name>
				</var>
			</parameters>
		</func>

		<func>
			<type>virtual void</type>
			<name>writeTexture</name>
			<parameters>
				<var>
					<type>TextureHandle</type>
					<name>t</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>subresource</name>
				</var>
				<var>
					<type>const void*</type>
					<name>data</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>rowPitch</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>depthPitch</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>destroyTexture</name>
			<parameters>
				<var>
					<type>TextureHandle</type>
					<name>t</name>
				</var>
				
			</parameters>
		</func>

		<func>
			<type>virtual BufferHandle</type>
			<name>createBuffer</name>
			<parameters>
				<var>
					<type>const BufferDesc&amp;</type>
					<name>d</name>
				</var>
				<var>
					<type>const void*</type>
					<name>data</name>
				</var>
			</parameters>
		</func>

		<func>
			<type>virtual void</type>
			<name>writeBuffer</name>
			<parameters>
				<var>
					<type>BufferHandle</type>
					<name>b</name>
				</var>
				<var>
					<type>const void*</type>
					<name>data</name>
				</var>
				<var>
					<type>size_t</type>
					<name>dataSize</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>clearBufferUInt</name>
			<parameters>
				<var>
					<type>BufferHandle</type>
					<name>b</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>clearValue</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>copyToBuffer</name>
			<parameters>
				<var>
					<type>BufferHandle</type>
					<name>dest</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>destOffsetBytes</name>
				</var>
				<var>
					<type>BufferHandle</type>
					<name>src</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>srcOffsetBytes</name>
				</var>
				<var>
					<type>size_t</type>
					<name>dataSizeBytes</name>
				</var>
			</parameters>
		</func>

		<func>
			<comment type="default">for debugging purposes only</comment>
			<type>virtual void</type>
			<name>readBuffer</name>
			<parameters>
				<var>
					<type>BufferHandle</type>
					<name>b</name>
				</var>
				<var>
					<type>void*</type>
					<name>data</name>
				</var>
				<var>
					<type>size_t*</type>
					<name>dataSize</name>
				</var>
				
			</parameters>
		</func>

		<func>
			<type>virtual void</type>
			<name>destroyBuffer</name>
			<parameters>
				<var>
					<type>BufferHandle</type>
					<name>b</name>
				</var>
			</parameters>
		</func>

		<func>
			<type>virtual ConstantBufferHandle</type>
			<name>createConstantBuffer</name>
			<parameters>
				<var>
					<type>const ConstantBufferDesc&amp;</type>
					<name>d</name>
				</var>
				<var>
					<type>const void*</type>
					<name>data</name>
				</var>
			</parameters>
		</func>

		<func>
			<type>virtual void</type>
			<name>writeConstantBuffer</name>
			<parameters>
				<var>
					<type>ConstantBufferDesc&amp;</type>
					<name>b</name>
				</var>
				<var>
					<type>const void*</type>
					<name>data</name>
				</var>
				<var>
					<type>size_t</type>
					<name>dataSize</name>
				</var>
			</parameters>
		</func>

		<func>
			<type>virtual void</type>
			<name>copyToConstantBuffer</name>
			<parameters>
				<var>
					<type>ConstantBufferDesc&amp;</type>
					<name>dest</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>destOffsetBytes</name>
				</var>
				<var>
					<type>BufferHandle</type>
					<name>src</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>srcOffsetBytes</name>
				</var>
				<var>
					<type>size_t</type>
					<name>dataSizeBytes</name>
				</var>
			</parameters>
		</func>


		<func>
			<type>virtual void</type>
			<name>destroyConstantBuffer</name>
			<parameters>
				<var>
					<type>ConstantBufferDesc&amp;</type>
					<name>b</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual ShaderHandle</type>
			<name>createShader</name>
			<parameters>
				<var>
					<type>const ShaderDesc&amp;</type>
					<name>d</name>
				</var>
				<var>
					<type>const void*</type>
					<name>binary</name>
				</var>
				<var>
					<type>const size_t</type>
					<name>binarySize</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>destroyShader</name>
			<parameters>
				<var>
					<type>ShaderHandle</type>
					<name>s</name>
				</var>
			</parameters>
		</func>

		<func>
			<type>virtual SamplerHandle</type>
			<name>createSampler</name>
			<parameters>
				<var>
					<type>const SamplerDesc&amp;</type>
					<name>d</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>destroySampler</name>
			<parameters>
				<var>
					<type>SamplerHandle</type>
					<name>s</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">This returns an api-specific handle which is required for some NVAPI operations.In D3D11 this is ID3D11DeviceContext*.In GL is is a HGLRC or EGLContext </comment>
			<type>virtual void*</type>
			<name>getAPISpecificInterface</name>
			<parameters>
				<var>
					<type>APISpecificInterface::Enum</type>
					<name>interfaceType</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">This function wraps the API specific shader handle with a ShaderHandle and transfers shader ownership to the backend. In D3D11, the handle is a ID3D11{Pixel,Compute,etc.}Shader*, according to shaderType. In GL, it's a separate program identifier. VXGI calls destroyShader when these handles are no longer needed, and the backend should properly destroy the shader.</comment>
			<type>virtual ShaderHandle</type>
			<name>createShaderFromAPIInterface</name>
			<parameters>
				<var>
					<type>ShaderDesc::SHADER_TYPE</type>
					<name>shaderType</name>
				</var>
				<var>
					<type>const void*</type>
					<name>apiInterface</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>drawNonIndexedVertices</name>
			<parameters>
				<var>
					<type>const DrawCallState&amp;</type>
					<name>state</name>
				</var>
				<var>
					<type>PrimitiveType::Enum</type>
					<name>primType</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>vertexCount</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>instanceCount</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>drawNonIndexedVerticesIndirect</name>
			<parameters>
				<var>
					<type>const DrawCallState&amp;</type>
					<name>state</name>
				</var>
				<var>
					<type>PrimitiveType::Enum</type>
					<name>primType</name>
				</var>
				<var>
					<type>BufferHandle</type>
					<name>indirectParams</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>offsetBytes</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>dispatchCompute</name>
			<parameters>
				<var>
					<type>const DispatchState&amp;</type>
					<name>state</name>
				</var>
				<var>
					<type>const Vector3u&amp;</type>
					<name>groupCount</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>dispatchComputeIndirect</name>
			<parameters>
				<var>
					<type>const DispatchState&amp;</type>
					<name>state</name>
				</var>
				<var>
					<type>BufferHandle</type>
					<name>indirectParams</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>offsetBytes</name>
				</var>
			</parameters>
		</func>

		<func>
			<comment type="default">A simple implementation would just look like {onCommand->executeAndDispose();}</comment>
			<type>virtual void</type>
			<name>executeRenderThreadCommand</name>
			<parameters>
				<var>
					<type>IRenderThreadCommand*</type>
					<name>onCommand</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">Normally you should just be able to return 0, for non-SLI or call NvAPI_D3D_GetCurrentSLIState. However, if the application is buffering frames this may require some more complex logic to implement. The application is passed the number of AFR groups VXGI thinks there is for validation.</comment>
			<type>virtual uint32_t</type>
			<name>getAFRGroupOfCurrentFrameForSLI</name>
			<parameters>
				<var>
					<type>uint32_t</type>
					<name>maxNumAFRGroups</name>
				</var>
			</parameters>
		</func>
	</class>

	<class name="IPerformanceMonitor" >
		<comment type="default">Should be implemented by the application. Not essential to VXGI operation and is useful for performance measurements only.
  class IPerformanceMonitor</comment>
		<func>
			<type>virtual void</type>
			<name>beginSection</name>
			<parameters>
				<var>
					<type>const char*</type>
					<name>pSectionName</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>endSection</name>
		</func>
	</class>

	<class name="IAllocator" >
		<comment type="default">Should be implemented by the application.</comment>
		<func>
			<type>virtual void*</type>
			<name>allocateMemory</name>
			<parameters>
				<var>
					<type>size_t</type>
					<name>size</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>freeMemory</name>
			<parameters>
				<var>
					<type>void*</type>
					<name>ptr</name>
				</var>
			</parameters>

		</func>
	</class>
	<class name="IErrorCallback" >
		<comment type="default">Should be implemented by the application.VXGI will call signalError(...) on every error it encounters, in addition to returning one of the failure status codes. The application can display a message box in case of errors.</comment>
		<func>
			<type>virtual void</type>
			<name>signalError</name>
			<parameters>
				<var>
					<type>const char*</type>
					<name>file</name>
				</var>
				<var>
					<type>int</type>
					<name>line</name>
				</var>
				<var>
					<type>const char*</type>
					<name>errorDesc</name>
				</var>
			</parameters>
		</func>
	</class>

	<class name="IViewTracer" >
		<struct name="InputBuffers">
			<comment type="default">Handles for G-buffer textures</comment>
			<var>
				<type>TextureHandle</type>
				<name>gbufferDepth</name>
				<comment type="default">Depth buffer, required</comment>
			</var>
			<var>
				<type>TextureHandle</type>
				<name>gbufferNormal</name>
				<comment type="default">Normals (.xyz) and roughness (.w)</comment>
			</var>
			<var>
				<type>TextureHandle</type>
				<name>gbufferGeoNormal</name>
				<comment type="default">Normals without normal maps (.xyz)</comment>
			</var>
			<comment type="default">Parameters of the camera that was used to render the G-buffer, required</comment>
			<var>
				<type>Matrix4f</type>
				<name>viewMatrix</name>
			</var>
			<var>
				<type>Matrix4f</type>
				<name>projMatrix</name>
			</var>
			<var>
				<type>Box3f</type>
				<name>gbufferViewport</name>
				<comment type="default">Viewport within the G-buffer textures, required</comment>
			</var>
			<comment type="default">Scale and bias for decoding the contents of gbufferNormal and gbufferGeoNormal textures. The effective normal N is computed like this: N = normalize(gbufferNormal.xyz * gbufferNormalScale + gbufferNormalBias).</comment>
			<var>
				<type>float</type>
				<name>gbufferNormalScale</name>
			</var>
			<var>
				<type>float</type>
				<name>gbufferNormalBias</name>
			</var>
			<var>
				<type>TextureHandle</type>
				<name>environmentMap</name>
				<comment type="default">Environment map to use when specular cones don't hit any geometry. Optional.</comment>
			</var>
			<default>
				<li>gbufferNormalScale(1.0f)</li>
				<li>gbufferNormalBias(0.0f)</li>
				<li>gbufferViewport(Vector3f(0,0,0),Vector3f(0,0,1.0f))</li>
				<li>gbufferDepth(0)</li>
				<li>gbufferNormal(0)</li>
				<li>gbufferGeoNormal(0)</li>
				<li>environmentMap(0)</li>
			</default>
		</struct>
		<func>
			<comment type="default">Computes the indirect diffuse illumination and returns the surface containing it.</comment>
			<type>virtual Status::Enum</type>
			<name>computeDiffuseChannel</name>
			<parameters>
				<var>
					<type>const DiffuseTracingParameters&amp;</type>
					<name>interfaceType</name>
				</var>
				<var>
					<type>TextureHandle&amp;</type>
					<name>outDiffuse</name>
				</var>
				<var>
					<type>const InputBuffers&amp;</type>
					<name>inputBuffers</name>
				</var>
				<var>
					<type>const InputBuffers*</type>
					<name>inputBuffersPreviousFrame = NULL</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">EXPERIMENTAL - DO NOT USE. Computes the indirect diffuse illumination and returns the surface containing it.</comment>
			<type>virtual Status::Enum</type>
			<name>computeDiffuseChannelAdaptive</name>
			<parameters>
				<var>
					<type>const DiffuseTracingParameters&amp;</type>
					<name>interfaceType</name>
				</var>
				<var>
					<type>TextureHandle&amp;</type>
					<name>outDiffuse</name>
				</var>
				<var>
					<type>const InputBuffers&amp;</type>
					<name>inputBuffers</name>
				</var>
				<var>
					<type>const InputBuffers*</type>
					<name>inputBuffersPreviousFrame = NULL</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">Computes the indirect specular illumination and returns the surface containing it.</comment>
			<type>virtual Status::Enum</type>
			<name>computeSpecularChannel</name>
			<parameters>
				<var>
					<type>SpecularTracingParameters&amp;</type>
					<name>interfaceType</name>
				</var>
				<var>
					<type>TextureHandle&amp;</type>
					<name>outDiffuse</name>
				</var>
				<var>
					<type>const InputBuffers&amp;</type>
					<name>inputBuffers</name>
				</var>
				<var>
					<type>const InputBuffers*</type>
					<name>inputBuffersPreviousFrame = NULL</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">Render the "debug samples" visualization for the samples that were previously saved using a setPixelToSave call followed by computeDiffuseChannel or computeSpecularChannel. Uses the matrices and viewport from the inputBuffers structure, all other fields are ignored.</comment>
			<type>virtual Status::Enum</type>
			<name>renderSamplesDebug</name>
			<parameters>
				<var>
					<type>TextureHandle</type>
					<name>destinationTexture</name>
				</var>
				<var>
					<type>TextureHandle</type>
					<name>destinationDepth</name>
				</var>
				<var>
					<type>const TracedSamplesParameters&amp;</type>
					<name>params</name>
				</var>
				<var>
					<type>const InputBuffers&amp;</type>
					<name>inputBuffers</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">Render the "tracer vision" visualization, which performs cone tracing from the camera rather than from the surfaces that are visible to the camera. Uses the matrices and viewport from the inputBuffers structure, all other fields are ignored.</comment>
			<type>virtual Status::Enum</type>
			<name>renderSamplesDebug</name>
			<parameters>				
				<var>
					<type>const TracedSamplesParameters&amp;</type>
					<name>params</name>
				</var>
				<var>
					<type>TextureHandle</type>
					<name>destinationTexture</name>
				</var>
				<var>
					<type>const InputBuffers&amp;</type>
					<name>inputBuffers</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">Sets the pixel for which to save texture samples performed during cone tracing.</comment>
			<type>virtual void</type>
			<name>setPixelToSave</name>
			<parameters>				
				<var>
					<type>int</type>
					<name>x</name>
				</var>
				<var>
					<type>int</type>
					<name>y</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">Returns the diffuse cone angle that is used for 'numCones' cones when autoConeAngle is true.</comment>
			<type>virtual float</type>
			<name>setPixelToSave</name>
			<parameters>				
				<var>
					<type>int</type>
					<name>numCones</name>
				</var>
			</parameters>
		</func>
	</class>



	<struct name="VoxelizationGeometryShaderDesc">
		<comment type="default">This structure describes the attributes that have to be passed through the voxelization geometry shader. The geometry shader code is generated by VXGI and is not available to the application.</comment>
		<enum name="Enum">
			<li>MAX_NAME_LENGTH = 512</li>
			<li>MAX_ATTRIBUTE_COUNT = 32</li>
		</enum>

		<enum name="AttributeType">
			<li>FLOAT_ATTR</li>
			<li>INT_ATTR</li>
			<li>UINT_ATTR</li>
		</enum>

		<enum name="InterpolationMode">
			<li>INTERPOLATION_LINEAR</li>
			<li>INTERPOLATION_CONSTANT</li>
			<li>INTERPOLATION_LINEAR_CENTROID</li>
			<li>INTERPOLATION_LINEAR_NOPERSPECTIVE</li>
			<li>INTERPOLATION_LINEAR_NOPERSPECTIVE_CENTROID</li>
			<li>INTERPOLATION_LINEAR_SAMPLE</li>
			<li>INTERPOLATION_LINEAR_NOPERSPECTIVE_SAMPLE</li>
		</enum>
		
		<struct name="Attribute">
			<var>
				<type>AttributeType</type>
				<name>type</name>
			</var>
			<var>
				<type>uint32_t</type>
				<name>width</name>
			</var>
			<var>
				<type>uint32_t</type>
				<name>semanticIndex</name>
			</var>
			<var>
				<type>InterpolationMode</type>
				<name>interpolationMode</name>
			</var>
			<var>
				<type>char[MAX_NAME_LENGTH]</type>
				<name>name</name>
			</var>
			<var>
				<type>char[MAX_NAME_LENGTH]</type>
				<name>semantic</name>
			</var>
		</struct>
		<var>
			<type>uint32_t</type>
			<name>pixelShaderInputCount</name>
		</var>
		<var>
			<type>Attribute</type>
			<name>pixelShaderInputs[MAX_ATTRIBUTE_COUNT]</name>
		</var>
	</struct>

	<struct name="VoxelizationPixelShaderDesc">
		<var>
			<type>const char*</type>
			<name>source</name>
		</var>
		<var>
			<type>size_t</type>
			<name>sourceSize</name>
		</var>
		<var>
			<type>const char*</type>
			<name>entryFunc</name>
		</var>
		<var>
			<type>ShaderResources*</type>
			<name>userShaderCodeResources</name>
		</var>
		<var>
			<type>bool</type>
			<name>useForOpacity</name>
		</var>
		<var>
			<type>bool</type>
			<name>useForEmmitance</name>
		</var>
		<var>
			<type>bool</type>
			<name>canUseDefaultOpacityShader</name>
		</var>
		<var>
			<type>bool</type>
			<name>useCoverageSupersampling</name>
		</var>
		<default>
			<li>source(NULL)</li>
			<li>sourceSize(0)</li>
			<li>entryFunc("main")</li>
			<li>userShaderCodeResources(NULL)</li>
			<li>useForOpacity(true)</li>
			<li>useForEmittance(true)</li>
			<li>canUseDefaultOpacityShader(false)</li>
			<li>useCoverageSupersampling(false)</li>
		</default>
	</struct>

	<struct name="VoxelizationGeometryShaderCullFunctionDesc">
		<comment type="default">This structure describes a user-defined triangle culling function, presented in HLSL source code. Such function is inserted into the VXGI voxelization geometry shader and can discard triangles early in the pipeline, based on vertex positions and/or triangle normal. For example, when voxelizing directly lit geometry, the culling function can test whether the triangle intersects with the light frustum and is facing the light. The function should be defined to match the following prototype; bool CullTriangle(float3 v1, float3 v2, float3 v3, float3 normal) { ... }
     - v1, v2, v3 are vertex coordinates in the same order as they're received by the GS;
  	 - normal is the triangle normal computed as normalize(cross(v1 - v0, v2 - v0));
     - returns true if the triangle has to be discarded, and false if it has to be voxelized.</comment>
		<var>
			<type>const char*</type>
			<name>sourceCode</name>
			<comment type="default">Pointer to the culling function source code in HLSL, not necessarily ending with a zero.</comment>
		</var>

		<var>
			<type>size_t</type>
			<name>sourceCodeSize</name>
			<comment type="default">Size of the source code, in bytes</comment>
		</var>

		<var>
			<type>ShaderResources</type>
			<name>resources</name>
			<comment type="default">Resources such as constant buffers or textures that are used by the culling function. These resources have to be bound by the application after applying the voxelization state that is produced by IGlobalIllumination::getVoxelizationState(...) function.</comment>
		</var>
	</struct>
	
	<class name="IBlob">
		<comment type="default">A container for binary data</comment>

		<func>
			<type>virtual const void*</type>
			<name>getData</name>
		</func>
		<func>
			<type>virtual size_t</type>
			<name>getSize</name>
		</func>
		<func>
			<comment type="default">The caller is finished with this object and it can be destroyed.</comment>
			<type>virtual void</type>
			<name>dispose</name>	
		</func>
	</class>

	<class name="IUserDefinedShaderSet">
		<enum name="ShaderType">
			<li>VOXELIZATION_GEOMETRY_SHADER</li>
			<li>VOXELIZATION_PIXEL_SHADER</li>
			<li>VOXELIZATION_SS_PIXEL_SHADER</li>
			<li>CONE_TRACING_PIXEL_SHADER</li>
			<li>CONE_TRACING_COMPUTE_SHADER</li>
		</enum>

		<func>
			<type>virtual ShaderType</type>
			<name>getType</name>
		</func>
		<comment type="default">There could be multiple versions of this shader inside.</comment>
		<func>
			<type>virtual uint32_t</type>
			<name>getPermutationCount</name>
		</func>
		<func>
			<type>ShaderHandle</type>
			<name>getApplicationShaderHandle</name>
			<parameters>
				<var>
					<type>uint32_t</type>
					<name>permutation</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">This allows the app to pre-compile these by creating  IUserDefinedShaderSets. This could the D3D blob, GLSL source, other VXGI data we need to store, etc...</comment>
			<type>virtual const void*</type>
			<name>getBinary</name>
			<parameters>
				<var>
					<type>size_t&amp;</type>
					<name>outBinarySize</name>
				</var>
			</parameters>	
		</func>
		<func>
			<comment type="default">An overload which uses the blob interface (for completeness). You must dispose this blob.</comment>
			<type>virtual IBlob*</type>
			<name>getBinary</name>
		</func>
	</class>

	<struct name="UpdateVoxelizationParameters">
		<var>
			<type>Vector3f</type>
			<name>clipmapAnchor</name>
			<comment type="default">Anchor is the point around which the clipmap center is located - it is snapped to a grid. For first-person cameras, the anchor should be placed slightly ahead of the camera, e.g. at (eyePosition + eyeDirection * giRange).</comment>
		</var>
		<var>
			<type>Box3f</type>
			<name>sceneExtents</name>
			<comment type="default">Scene bounding box in world space - used to stop cone tracing when cones exit the scene.</comment>
		</var>
		<var>
			<type>float</type>
			<name>giRange</name>
			<comment type="default">Size of the finest clipmap level, in world units.</comment>
		</var>
		<var>
			<type>const Box3f*</type>
			<name>invalidatedRegions</name>
			<comment type="default">A set of world-space boxes that contain some geometry that changed since the previous frame.</comment>
		</var>
		<var>
			<type>uint32_t</type>
			<name>invalidatedRegionCount</name>
			<comment type="default">The number of boxes in 'invalidatedRegions'.</comment>
		</var>
		<var>
			<type>const LightDesc*</type>
			<name>lights</name>
			<comment type="default">Light descriptors.</comment>
		</var>
		<var>
			<type>uint32_t</type>
			<name>lightCount</name>
			<comment type="default">The number of descriptors in 'lights'.</comment>
		</var>
		<var>
			<type>IrradianceMapTracingParameters</type>
			<name>irradianceMapTracingParameters</name>
			<comment type="default">Parameters that control the cone tracing process used for the irradiance map. The nearClipZ, farClipZ and debugParameters members of CommonTracingParameters are ignored here, all others are effective.</comment>
		</var>
		<default>
			<li>clipmapAnchor(0.f)</li>
			<li>sceneExtents(Vector3f(FLT_MIN), Vector3f(FLT_MAX))</li>
			<li>giRange(512.0f)</li>
			<li>invalidatedRegions(NULL)</li>
			<li>invalidatedRegionCount(0)</li>
			<li>lights(NULL)</li>
			<li>lightCount(0)</li>
		</default>
	</struct>

	<class name="IGlobalIllumination">
		<comment>The primary interface for interaction with VXGI. An instance of object implementing this interface can be created with VFX_VXGI_CreateGIObject and destroyed with VFX_VXGI_DestroyGIObject.</comment>
		<func>
			<comment type="default">Returns the hash of the VXGI shaders that compose the IUserDefinedShaderSets. If this does not match the application must compile new voxelization shaders or else loadUserDefinedShaderSet will reject them.</comment>
			<type>virtual uint64_t</type>
			<name>getInternalShaderHash</name>
		</func>

		<func>
			<comment type="default">Creates a view tracer and allocated its resources. The device reference is assumed to stay valid until the next call to ReleaseResources().</comment>
			<type>virtual Status::Enum</type>
			<name>createNewTracer</name>
			<parameters>
				<var>
					<type>IViewTracer**</type>
					<name>ppTracer</name>
				</var>
			</parameters>
		</func>

		<func>
			<comment type="default">Releases all the previously created resources for a specific tracer and forgets the previously supplied device reference.</comment>
			<type>virtual void</type>
			<name>destroyTracer</name>
			<parameters>
				<var>
					<type>IViewTracer*</type>
					<name>pTracer</name>
				</var>
			</parameters>
		</func>

		<func>
			<comment type="default">Get the current scene interface.</comment>
			<type>virtual IRendererInterface*</type>
			<name>GetRendererInterfaceInl</name>
		</func>
		<func>
			<comment type="default">This can be used to find out what getWorldRegion will be after a future call to updateGlobalIllumination.</comment>
			<type>virtual IPerformanceMonitor*</type>
			<name>getPerformanceMonitor</name>
		</func>

		<func>
			<comment type="default">Gets the performance monitor.</comment>
			<type>virtual Box3f</type>
			<name>calculateHypotheticalWorldRegion</name>
			<parameters>
				<var>
					<type>Vector3f&amp;</type>
					<name>clipmapAnchor</name>
				</var>
				<var>
					<type>float</type>
					<name>giRange</name>
				</var>
			</parameters>
		</func>

		<func>
			<comment type="default">This function performs all steps necessary to begin voxelization for a new frame. It should only be called once per frame. The performOpacityVoxelization and performEmittanceVoxelization reference parameters are returned from this function, indicating whether the application is allowed to perform opacity or emittance voxelization draw calls on this frame, respectively. If the app tries to call getVoxelizationState when the respective perform... value is false, an INVALID_STATE error will be returned.</comment>
			<type>virtual Status::Enum</type>
			<name>prepareForOpacityVoxelization</name>
			<parameters>
				<var>
					<type>const UpdateVoxelizationParameters&amp;</type>
					<name>params</name>
				</var>
				<var>
					<type>bool&amp;</type>
					<name>performOpacityVoxelization</name>
				</var>
				<var>
					<type>bool&amp;</type>
					<name>performEmittanceVoxelization</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">This function performs some steps necessary to move from opacity voxelization to emittance voxelization. If your voxelization shaders use opacity cone tracing, set enableOpacityTracing = true, otherwise the result of tracing will be incorrect. It is not recommended to set enableOpacityTracing = true in the other case because that will result in an unnecessary (although small) performance degradation.</comment>
			<type>virtual Status::Enum</type>
			<name>prepareForEmittanceVoxelization</name>
		</func>
		<func>
			<comment type="default">Marks the beginning of a group of independent draw calls used for voxelization, useful for performance. If this function is not called, a barrier will be inserted by the D3D runtime between these draw calls because they use a UAV. Inside, this methods enqueues a call to NvAPI_D3D11_BeginUAVOverlap, which removes the barrier.</comment>
			<type>virtual Status::Enum</type>
			<name>beginVoxelizationDrawCallGroup</name>
		</func>
		<func>
			<comment type="default">Marks the end of a group of independent draw calls used for voxelization. Inside, this methods enqueues a call to NvAPI_D3D11_EndUAVOverlap.</comment>
			<type>virtual Status::Enum</type>
			<name>endVoxelizationDrawCallGroup</name>
		</func>
		<func>
			<comment type="default">Returns the list of world-space regions that have to be revoxelized on this frame. The list is based on the invalidatedRegions list passed to prepareForVoxelization(...), but is more complete and optimized. Specifically, this list contains extra regions that are created from camera movements, and all regions in the list are snapped to the allocation map page grid. If the buffer passed as pRegions is too small, a BUFFER_TOO_SMALL error is returned, and numRegions contains a valid number. Call getInvalidatedRegions(0, 0, numRegions) to get the number of regions and allocate the buffer based on that.</comment>
			<type>virtual Status::Enum</type>
			<name>getInvalidatedRegions</name>
			<parameters>
				<var>
					<type>Box3f*</type>
					<name>pRegions</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>maxRegions</name>
				</var>
				<var>
					<type>uint32_t&amp;</type>
					<name>numRegions</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">Returns the list of light IDs that have to be reinjected on this frame. If the buffer passed as pLights is too small, a BUFFER_TOO_SMALL error is returned, and numLights contains a valid number. Call getInvalidatedLights(0, 0, numLights) to get the number of lights and allocate the buffer based on that.</comment>
			<type>virtual Status::Enum</type>
			<name>getInvalidatedLights</name>
			<parameters>
				<var>
					<type>LightHandle*</type>
					<name>pLights</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>maxRegions</name>
				</var>
				<var>
					<type>uint32_t&amp;</type>
					<name>numRegions</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">Returns the view matrix that has to be used for voxelization draw calls. The projection matrix is always identity.</comment>
			<type>virtual Status::Enum</type>
			<name>getVoxelizationViewMatrix</name>
			<parameters>
				<var>
					<type>Matrix4f&amp;</type>
					<name>viewMatrix</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">Computes the state necessary to perform opacity voxelization or emittance voxelization for a given material. If this function is called after prepareForOpacityVoxelization(...), a state for opacity voxelization is returned; if it is called after prepareForEmittanceVoxelization(), a state for emittance voxelization is returned, and otherwise an INVALID_STATE error is returned. In order to voxelize geometry, set the returned state and don't forget to call preDraw/postDraw functions of the state. The state object passed into this function will be completely overwritten.</comment>
			<type>virtual Status::Enum</type>
			<name>getVoxelizationState</name>
			<parameters>
				<var>
					<type>const MaterialInfo&amp;</type>
					<name>materialInfo</name>
				</var>
				<var>
					<type>DrawCallState&amp;</type>
					<name>state</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">This is a lightweight version of getVoxelizationState that only changes constant buffer contents. It's safe to call this function if MaterialInfo::requiresParameterUpdate returns true, but MaterialInfo::requiresNewState returns false.</comment>
			<type>virtual Status::Enum</type>
			<name>updateVoxelizationMaterialParameters</name>
			<parameters>
				<var>
					<type>const MaterialInfo&amp;</type>
					<name>materialInfo</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">Finalizes all voxel representation updates and prepares for cone tracing. Also performs RSM-based scatter light injection, if any lights passed to perpareForVoxelization(...) have RSM textures.</comment>
			<type>virtual Status::Enum</type>
			<name>finalizeVoxelization</name>
			<parameters>
				<var>
					<type>const MaterialInfo&amp;</type>
					<name>materialInfo</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">Renders a visualization of one of the voxel textures.</comment>
			<type>virtual Status::Enum</type>
			<name>renderDebug</name>
			<parameters>
				<var>
					<type>DebugRenderMode::Enum</type>
					<name>debugMode</name>
					<comment>Which texture?</comment>
				</var>
				<var>
					<type>const Matrix4f&amp;</type>
					<name>viewMatrix</name>
					<comment>Camera paramaters.</comment>
				</var>
				<var>
					<type>const Matrix4f&amp;</type>
					<name>projMatrix</name>
				</var>
				<var>
					<type>const Box3f&amp;</type>
					<name>viewport</name>
				</var>
				<var>
					<type>TextureHandle</type>
					<name>destinationTexture</name>
					<comment>Required.</comment>
				</var>
				<var>
					<type>TextureHandle</type>
					<name>destinationDepth</name>
					<comment>Optional - use it to correctly overlay the voxels over the scene rendering.</comment>
				</var>
				<var>
					<type>const BlendState*</type>
					<name>blendState</name>
					<comment>If blendState is NULL then the render target will be cleared before rendering.</comment>
				</var>
				<var>
					<type>uint32_t</type>
					<name>level</name>
					<comment>Clipmap level to visualize (for opacity and emittance views).</comment>
				</var>
				<var>
					<type>uint32_t</type>
					<name>bitToDisplay</name>
					<comment>Allocation map bit index to visualize (for the allocation map view).</comment>
				</var>
				<var>
					<type>float</type>
					<name>voxelsToSkip</name>
					<comment>Number of voxel faces to look through.</comment>
				</var>
				<var>
					<type>float</type>
					<name>nearClipZ = 0.0f</name>
					<comment>Projetion parameters.</comment>
				</var>
				<var>
					<type>float</type>
					<name>farClipZ = 1.0f</name>
				</var>
			</parameters>
		</func>

		<comment type="default">These functions bind the VXGI related resources to the user defined tracing shader. You can add any other resources that your shader needs, but they have to be declared as ShaderResources in the corresponding createConeTracing{Pixel,Compute}Shader(...) call. After the state is set, you can do any number of draw calls or dispatches with that state, which stays valid until the next call to updateGlobalIllumination.</comment>
		<func>
			<type>virtual Status::Enum</type>
			<name>setupUserDefinedConeTracingPixelShaderState</name>
			<parameters>
				<var>
					<type>IUserDefinedShaderSet*</type>
					<name>shaderSet</name>
				</var>
				<var>
					<type>DrawCallState&amp;</type>
					<name>state</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual Status::Enum</type>
			<name>setupUserDefinedConeTracingComputeShaderState</name>
			<parameters>
				<var>
					<type>IUserDefinedShaderSet*</type>
					<name>shaderSet</name>
				</var>
				<var>
					<type>DrawCallState&amp;</type>
					<name>state</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual const Box3f&amp;</type>
			<name>getLastUpdatedWorldRegion</name>
		</func>

		<func>
			<type>virtual const Box3f&amp;</type>
			<name>getLastUpdatedSceneExtents</name>
		</func>

		<func>
			<type>virtual const Vector3f&amp;</type>
			<name>getLastUpdatedClipmapAnchor</name>
		</func>
		<comment type="default">Functions that create a voxelization geometry shader based on.</comment>
		<func>
			<type>virtual Status::Enum</type>
			<name>createVoxelizationGeometryShader</name>
			<comment>A descriptor listing the attributes to pass through the GS.</comment>
			<parameters>
				<var>
					<type>IUserDefinedShaderSet**</type>
					<name>ppShaderSet</name>
				</var>
				<var>
					<type>const VoxelizationGeometryShaderDesc&amp;</type>
					<name>desc</name>
				</var>
				<var>
					<type>const VoxelizationGeometryShaderCullFunctionDesc*</type>
					<name>cullFunction = NULL</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual Status::Enum</type>
			<name>createVoxelizationGeometryShaderFromVS</name>
			<comment>A vertex shader; shader reflection is used to get the list of attributes.</comment>
			<parameters>
				<var>
					<type>IUserDefinedShaderSet**</type>
					<name>ppShaderSet</name>
				</var>
				<var>
					<type>const void*</type>
					<name>binary</name>
				</var>
				<var>
					<type>size_t</type>
					<name>binarySize</name>
				</var>
				<var>
					<type>const VoxelizationGeometryShaderCullFunctionDesc*</type>
					<name>cullFunction = NULL</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual Status::Enum</type>
			<name>createVoxelizationGeometryShaderFromDS</name>
			<comment>A domain shader; shader reflection is used to get the list of attributes.</comment>
			<parameters>
				<var>
					<type>IUserDefinedShaderSet**</type>
					<name>ppShaderSet</name>
				</var>
				<var>
					<type>const void*</type>
					<name>binary</name>
				</var>
				<var>
					<type>size_t</type>
					<name>binarySize</name>
				</var>
				<var>
					<type>const VoxelizationGeometryShaderCullFunctionDesc*</type>
					<name>cullFunction = NULL</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual Status::Enum</type>
			<name>createVoxelizationDefaultPixelShader</name>
			<comment>Creates a default voxelization PS that is only useful for opacity voxelization of opaque geometry. When used for emittance voxelization, this shader produces flat white emissive geometry.</comment>
			<parameters>
				<var>
					<type>IUserDefinedShaderSet**</type>
					<name>ppShaderSet</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual Status::Enum</type>
			<name>createVoxelizationDefaultPixelShader</name>
			<comment>Creates a custom voxelization PS that can be used for both opacity and emittance voxelization. Static const int VXGI::IsEmissiveVoxelizationPass is defined to help the user code tell whether it's compiled for opacity voxelization (0) or emittance voxelization (1). VXGI::GetIrradiance(...) function is also available to the user code to get the indirect irradiance, see the comments for VoxelizationParameters::multiBounceMode for more details. The useForOpacity and useForEmittance parameters control whether this shader will be used for opacity and emittance voxelization, respectively. When one of this flags is false and the shader is actually used for that kind of voxelization, calling getVoxelizationState will return a SHADER_MISSING error. If canUseDefaultOpacityShader parameter is set to true, VXGI will try to use the default opacity voxelization PS. It will only succeed if the resource bindings that are generated automatically for the emittance voxelization PS and the default resource bindings match. This means that the user code should claim that it requires only b0 and no other resources in slots lower than 9. If the resource bindings do not match, a new PS will be compiled.</comment>
			<parameters>
				<var>
					<type>IUserDefinedShaderSet**</type>
					<name>ppShaderSet</name>
				</var>
				<var>
					<type>const VoxelizationPixelShaderDesc&amp;</type>
					<name>desc</name>
				</var>
			</parameters>
		</func>

		<comment>Functions that create user defined shaders that use VXGI cone tracing functions.</comment>
		<func>
			<type>virtual Status::Enum</type>
			<name>createConeTracingPixelShader</name>
			<parameters>
				<var>
					<type>IUserDefinedShaderSet**</type>
					<name>ppShaderSet</name>
				</var>
				<var>
					<type>const char*</type>
					<name>source</name>
				</var>
				<var>
					<type>size_t</type>
					<name>sourceSize</name>
				</var>
				<var>
					<type>const char*</type>
					<name>entryFunc</name>
				</var>
				<var>
					<type>const ShaderResources&amp;</type>
					<name>userShaderCodeResources</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual Status::Enum</type>
			<name>createConeTracingComputeShader</name>
			<parameters>
				<var>
					<type>IUserDefinedShaderSet**</type>
					<name>ppShaderSet</name>
				</var>
				<var>
					<type>const char*</type>
					<name>source</name>
				</var>
				<var>
					<type>size_t</type>
					<name>sourceSize</name>
				</var>
				<var>
					<type>const char*</type>
					<name>entryFunc</name>
				</var>
				<var>
					<type>const ShaderResources&amp;</type>
					<name>userShaderCodeResources</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual bool</type>
			<name>isValidUserDefinedShaderBinary</name>
			<comment>Tests whether the user defined shader binary is compatible with the current version of VXGI library. If it isn't, you should recompile the shader and generate a new binary.</comment>
			<parameters>
				<var>
					<type>const void*</type>
					<name>binary</name>
				</var>
				<var>
					<type>size_t</type>
					<name>binarySize</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual IUserDefinedShaderSet::ShaderType</type>
			<name>getUserDefinedShaderBinaryType</name>
			<comment>Extracts the shader type descriptor from the binary.</comment>
			<parameters>
				<var>
					<type>const void*</type>
					<name>binary</name>
				</var>
				<var>
					<type>size_t</type>
					<name>binarySize</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual uint32_t</type>
			<name>getUserDefinedShaderBinaryPermutationCount</name>
			<comment>Gets the number of specific shader permutations stored in a binary.</comment>
			<parameters>
				<var>
					<type>const void*</type>
					<name>binary</name>
				</var>
				<var>
					<type>size_t</type>
					<name>binarySize</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual IBlob*</type>
			<name>getUserDefinedShaderBinaryReflectionData</name>
			<comment>You must free these blobs.</comment>
			<parameters>
				<var>
					<type>const void*</type>
					<name>binary</name>
				</var>
				<var>
					<type>size_t</type>
					<name>binarySize</name>
				</var>
				<var>
					<type>uint32_t</type>
					<name>permutation</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual IBlob*</type>
			<name>stripUserDefinedShaderBinary</name>
			<comment>This may do nothing if the API doesn't support this.</comment>
			<parameters>
				<var>
					<type>const void*</type>
					<name>binary</name>
				</var>
				<var>
					<type>size_t</type>
					<name>binarySize</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual Status::Enum</type>
			<name>loadUserDefinedShaderSet</name>
			<comment>Loads the previously compiled user defined shader from a binary representation. The binary can be obtained with IUserDefinedShaderSet::getBinary(...) and stored somewhere to speed up application startup.</comment>
			<parameters>
				<var>
					<type>IUserDefinedShaderSet**</type>
					<name>ppShaderSet</name>
				</var>
				<var>
					<type>const void*</type>
					<name>binary</name>
				</var>
				<var>
					<type>const void*</type>
					<name>binarySize</name>
				</var>
				<var>
					<type>bool</type>
					<name>reportNoErrorsOnInvalidBinaryFormat = false</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual void</type>
			<name>destroyUserDefinedShaderSet</name>
			<comment>Destroys a user defined shader set previously created with one of the above functions.</comment>
			<parameters>
				<var>
					<type>IUserDefinedShaderSet*</type>
					<name>shader</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual Status::Enum</type>
			<name>voxelizeTestScene</name>
			<comment>Renders something simple (currently a cube) into the voxel textures. Call this function after prepareForOpacityVoxelization and/or prepareForEmittanceVoxelization to test the rendering backend implementation separately from your scene voxelization code.</comment>
			<parameters>
				<var>
					<type>Vector3f</type>
					<name>testObjectPosition</name>
				</var>
				<var>
					<type>float</type>
					<name>testObjectSize</name>
				</var>
			</parameters>
		</func>
		<func>
			<type>virtual bool</type>
			<name>areNvidiaExtensionsUsed</name>
			<comment>Returns true if Maxwell [*] extended features are actually being used.</comment>
		</func>
	</class>

	<struct name="GIParameters">
		<var>
			<type>VoxelizationParameters</type>
			<name>voxelizationParamters</name>
		</var>
		<var>
			<type>IRendererInterface*</type>
			<name>rendererInterface</name>
		</var>
		<var>
			<type>IPerformanceMonitor*</type>
			<name>perfMonitor</name>
		</var>
		<var>
			<type>IAllocator*</type>
			<name>allocator</name>
		</var>
		<var>
			<type>IErrorCallback*</type>
			<name>errorCallback</name>
		</var>

		<enum name="SHADER_TYPE">
			<li>ST_D3D_BYTECODE_SM50</li>
			<li>ST_GLSL_430_SEPARATE_SHADER_OBJECTS</li>
			<li>SHADER_TYPE_COUNT</li>
		</enum>

		<var>
			<type>SHADER_TYPE</type>
			<name>shaderType</name>
		</var>


		<var>
			<type>char*</type>
			<name>d3dCompilerDLLName</name>
			<comment type="default">you can use this to override the DLL VXGI will use to match your appliation</comment>
		</var>

		<var>
			<type>bool</type>
			<name>multicoreShaderCompilation</name>
		</var>

		<default>
			<li>rendererInterface(0)</li>
			<li>perfMonitor(0)</li>
			<li>allocator(0)</li>
			<li>shaderType(ST_D3D_BYTECODE_SM50)</li>
			<li>d3dCompilerDLLName(NULL)</li>
			<li>errorCallback(0)</li>
			<li>multicoreShaderCompilation(true) </li>
		</default>
	</struct>

	<interface name="extern C">
		<func>
			<comment type="default">Creates a root interface object for VXGI. The interfaceVersion parameter is there to make sure that the VXGI DLL is built with the same version of the headers as the user code. If the interface versions do not match, this method will return WRONG_INTERFACE_VERSION.</comment>
			<type>GI_COMPILER_ATTRS Status::Enum</type>
			<name>VFX_VXGI_CreateGIObject</name>
			<parameters>
				<var>
					<type>GIParameters&amp;</type>
					<name>params</name>
				</var>
				<var>
					<type>IGlobalIllumination**</type>
					<name>ppGI</name>
				</var>
				<var>
					<type>Version</type>
					<name>version = Version()</name>
				</var>
			</parameters>

		</func>
		<func>
			<comment type="default">Compares the version of the header that the user code was built with and the version that VXGI was built with.Returns OK if the versions match, and WRONG_INTERFACE_VERSION otherwise.</comment>
			<type>GI_COMPILER_ATTRS Status::Enum</type>
			<name>VFX_VXGI_VerifyInterfaceVersion</name>
			<parameters>
				<var>
					<type>Version</type>
					<name>version = Version()</name>
				</var>
			</parameters>
		</func>
		<func>
			<comment type="default">This method returns a hash of VXGI shader fragments that are linked together with user-defined voxelization or cone tracing shaders. User code may store the compiled shaders in binary format and re-use them as long as this shader hash stays the same. The shader hash is also verified in IGlobalIllumination::loadUserDefinedShaderSet, so it is not necessary to store it separately.</comment>
			<type>GI_COMPILER_ATTRS uint64_t</type>
			<name>VFX_VXGI_GetInternalShaderHash</name>
			<parameters>
				<var>
					<type>Version</type>
					<name>version = Version()</name>
				</var>
			</parameters>

		</func>
		<func>
			<comment type="default">Destroys a previously created instance of the VXGI interface object.</comment>
			<type>GI_COMPILER_ATTRS void</type>
			<name>VFX_VXGI_DestroyGIObject</name>
			<parameters>
				<var>
					<type>IGlobalIllumination*</type>
					<name>gi</name>
				</var>
			</parameters>

		</func>
		<func>
			<comment type="default">Converts a status code to a string containing the name of that status code, e.g. "NULL_ARGUMENT".</comment>
			<type>GI_COMPILER_ATTRS const char*</type>
			<name>VFX_VXGI_StatusToString</name>
			<parameters>
				<var>
					<type>Status~::Enum</type>
					<name>status</name>
				</var>
			</parameters>

		</func>
	</interface>

</namespace>

