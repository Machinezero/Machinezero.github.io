<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>VXGI - Voxel Global Illumination</title>

    <link href="css-js/css/bootstrap.min.css" rel="stylesheet">

    <link href="css-js/css/landing-page.css" rel="stylesheet">

    <link href="css-js/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="css-js/fonts/lato.css" rel="stylesheet" type="text/css">

    <script src="css-js/js/jquery.js"></script>
    <script src="css-js/fullScreen/jqueryFull.js"></script>
    <script src="css-js/js/bootstrap.min.js"></script>

    


    <link href="css-js/fullScreen/fullscreenstyle.css" rel="stylesheet" type="text/css"></link>

    <script src="css-js/fullScreen/jquery.fullscreenslides.min.js"></script>
    <script src="css-js/fullScreen/jquery.fullscreenslides.js"></script>
    <script src="css-js/fullScreen/fullScreen.js"></script>

    <script type="text/javascript">
    $(document).ready(function(){
    
        $(".list-inline").on("click",'.emailAlu', function(){
            $(this).find('.name:visible').slideUp(1);
            $(this).find('.name:hidden').delay(10).slideDown(1);
            $(this).find('.email:visible').slideUp(1);
            $(this).find('.email:hidden').delay(10).slideDown(1);
            
            
        });
    });
    </script>

    <script>
    function hide(i) {
        if(document.getElementById(i).style.display == "none"){
            $("#"+i).slideDown(200);
        }
        else{
            $("#"+i).slideUp(200);
        }
    }
    </script>

    <script>
    $(document).ready(function(){
        var hash=$(location).attr('hash');
        $("div " + hash).fadeIn(2000);
    });
    </script>
</head>

<body>
    <!-- Header -->
    <div class="intro-header">
        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <div class="intro-message">
                        <h1>VXGI</h1>
                        <h3>Voxel Global Illumination</h3>
                        <hr class="intro-divider">
                        <ul class="list-inline intro-social-buttons">
                            <li>
                                <a id="alud"  class="btn btn-default btn-lg emailAlu"><span class="name"><i class="fa fa-google"></i><span class="network-name">&nbsp;&nbsp;FÃ¡bio Dias</span> </span><span class="network-name email" style="display:none">a64330@alunos.uminho.pt</span></a>
                                
                            </li>
                            <li>
                                <a id="H" class="btn btn-default btn-lg emailAlu"><span class="name"><i class="fa fa-google"></i> <span class="network-name">&nbsp;&nbsp;Helder Novais</span></span><span class="network-name email" style="display:none" >a64378@alunos.uminho.pt</span></a>
                            </li>
                            <li>
                                <a id="P" class="btn btn-default btn-lg emailAlu"><span class="name"><i class="fa fa-google"></i> <span class="network-name">&nbsp;&nbsp;Pedro Carvalho</span></span><span class="network-name email" style="display:none" >a64367@alunos.uminho.pt</span></a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

        </div>

    </div>

    <div class="articlePost">
        <div class="row">
            <div id="a" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1" style="display:none">
                <a name="a"></a>
                <h1 class="articleTitle">What is VXGI?</h1>
                <p>Voxel Global Illumination, VXGI, it is a new way, developed by <i>NVIDIA</i>, to simulate Global Ilumination.</p>
                <blockquote style="font-family: 'Tahoma'; color:white"> <i>Voxel Global Illumination (VXGI) is a stunning advancement, delivering incredibly realistic lighting, shading and reflections to next-generation games and game engines.</i>
                <br/>
                <h3 style="font-weight:normal; text-align:right; font-family: 'Trocchi', serif">
                    <i>NVIDIA</i>
                </h3>
                </blockquote>

                <p>The VXGI is a software library of a very complex rendering technique. This algorithm uses Voxel Cone Tracing to accumulate light contributions in the scene. This can not be build into the graphics driver, so we can not switch the graphical properties if we want to use it in a game, for example. It needs to be integrated into the game engine, but it is hard to do it. Only the Unreal Engine 4 supports this technology, for now.</p>

                <p>This technique differs on previous alternatives because it uses a different data structure to encode the voxel data. Instead of using a Sparse Voxel Octree (like the Sparse Voxel Octree Global Illumination (SVOGI)) , it uses a 3D Clipmap.</p>

                <p>A clipmap is a hierarchical data structure similar to a 3D mipmap with the difference of clipping finer levels, in order to don't exceed a pre-defined size.</p>

                <p>The algorithm encodes the opacity and emittance information in the climaps and the executes the Voxel Cone Tracing to compute approximately the global illumination in real time.</p>
            </div>

            <div id="b" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1" style="display:none">
                <a name="b"></a>
                <h1 class="articleTitle">How VXGI works?</h1>

                <p>The main steps of the VXGI technique consists on the voxelization of the scene, encoding the opacity and emittance information in the clipmap and then is used the voxel cone tracing to compute the global illumination.</p>

                <h2 class="articleSubTitle" onclick="hide('3dclip')">3D Clipmap</h2>

                <div id="3dclip">
                    <a name="3dclip" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1" style="display:none"></a>
                    <!--<p>Clipmaps are multidimensional textures that were proposed as a solution to reduce the memory footprint of very large textures (<a href="http://doi.acm.org/10.1145/280814.280855" target="_blank">Tanner et al., 1998</a>), (<a href="http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter02.html" target="_blank">Asirvatham and Hoppe, 2005</a>).</p>

                    <p>A clipmap is a partial representation of a mipmap, in which the levels are clipped according to a user-defined maximum size (<a href="http://www4.di.uminho.pt/~arf/supervision/DanielGomesVoxelRendering.pdf" target="_blank">Daniel Gomes et al, 2015</a>). The clipmaps only differ from mipmaps in the finer levels of detail. So the finer levels have the same number of voxels, but the same spatial resolution as the mipmap.</p>

                    <p>The regions near the camera are represented with finer levels of detail and far regions with coarser levels of detail. This maps nicely when applying voxel cone tracing, due to the higher spatial density of pixels near the camera.</p>

                    <p>When the camera moves, we don't need to update de clipmap completely, since only a small portion of the clipmap needs to be updated because most of the data is already present in the clipmap since it was needed in the previous frame.</p>-->
                    <p>A <i>Clipmap</i> is a multidimensional texture that were proposed as a solution to reduce the memory footprint of very large textures (<a href="http://www.cs.virginia.edu/~gfx/courses/2002/BigData/papers/Texturing/Clipmap.pdf" target="_blank">Tanner et al., 1998</a>), (<a href="http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter02.html" target="_blank">Asirvatham and Hoppe, 2005</a>).</p>
                    <p>For that purpose each level need to be clipped to a user-specified maximum size (<i>ClipSize</i>). This parameterization results in an obelisk shape for clipmaps as opposed to the pyramid of mipmaps. It also defines the size of the texture memory cache needed to fully represent the texture hierarchy.</p>
                    <p>ClipSize represents the limit, in texels, for any single level of a clipmap texture. In a normal mipmap, the texture size in memory would be bigger. Instead, the Clipmap retain the logical size and render-time accessing the corresponding level of a full mipmap.</p>
                    <p>Further is defined the <it>Clipmap Stack</it> that is the set of levels that have been clipped from ful mipmap-size by the limit established. The levels at the topmost in the figure below are not fully resident within the Clipmap; only a ClipSize subset is cached.</p>
                    <br>
					<center>
                    	<img class="img-responsive" src="img/Clipmap.png" alt="">Clipmap Stack and Pyramid Levels. <i>Source:<a href="http://www.cs.virginia.edu/~gfx/courses/2002/BigData/papers/Texturing/Clipmap.pdf" target="_blank"> Tanner et al., 1998</a></i>
					</center>
					<br>
					<p>Below the Clipmap Stack is the Clipmap Pyramid, defined as the set of levels of sizes lower than the ClipSize limit. These levels are completely stored in texture memory and have the same spatial resolution of a full mipmap. </p>
                    <p>The regions near the camera are represented with finer levels of detail and far regions with coarser levels of detail. This maps nicely when applying voxel cone tracing, due to the higher spatial density of pixels near the camera (<a href="http://www4.di.uminho.pt/~arf/supervision/DanielGomesVoxelRendering.pdf" target="_blank">Daniel Gomes et al, 2015</a>).</p>
                    <p>To prove the Clipmap storage efficiency lets consider a 13 level 4096<sup>2</sup> Clipmap to be rendered on a 1024<sup>2</sup> display. Given the display size, we know that the upper bound on texture usage from a single level is 2048<sup>2</sup>, so we must set the Clipsize to 2048. There will be one clipped level forming our Clipmap Stack and 12 levels in the Clipmap Pyramid. The storage required for this is 2048<sup>2</sup> texels * 1 level + 4/3 * 2048<sup>2</sup> for the pyramid = 18.7 MB at 2 bytes per texel. This clipmap configuration requires only 18.7 MB of the full 42.7 MB of a full mipmap. The bigger the size of the clipmap, the bigger is the difference of memory usage between the mipmap and Clipmap. This is essencial to store the textures on the graphics dedicated memory and avoid constant swaps with RAM. The table below shows the diferences.</p>
                    <br>
					<center>
                    	<img class="img-responsive" src="img/Clipmap_storage.png" alt="">Clipmap Storage. <i>Source:<a href="http://www.cs.virginia.edu/~gfx/courses/2002/BigData/papers/Texturing/Clipmap.pdf" target="_blank"> Tanner et al., 1998</a></i>
					</center>
					<br>
					<p>The clipmap must however be updated when the camera moves in order to maintain all the information needed around the camera to render the current frame. In order to prevent having to update the clipmap completely each time the camera moves, it is possible to take advantage of the fact that usually only a small part of the clipmap needs to be updated (a great portion of the data is already present in the Clipmap since it was needed in the previous frame) (<a href="http://www4.di.uminho.pt/~arf/supervision/DanielGomesVoxelRendering.pdf" target="_blank">Daniel Gomes et al, 2015</a>). In order to update the Clipmap incrementally with the needed data, toroidal addressing is used (<a href="http://www.cs.virginia.edu/~gfx/courses/2002/BigData/papers/Texturing/Clipmap.pdf" target="_blank">Tanner et al., 1998</a>). Toroidal addressing is a method that guarantees that a point in space always maps to the same point in the texture as shown in the next image.</p>
					<br>
                	<center>
                    	<img class="img-responsive" src="img/toroidal.png" alt="">Toroidal Addressing. <i>Source:<a href="http://www.cs.virginia.edu/~gfx/courses/2002/BigData/papers/Texturing/Clipmap.pdf" target="_blank"> Tanner et al., 1998</a></i>
					</center>
                </div>

                <h2 class="articleSubTitle" onclick="hide('opacity')">Opacity Voxelization</h2>

                <div id="opacity" style="display:none">
                    <p>The first step of the VXGI algorithm is the opacity voxelization and downsampling (<a href="http://developer.download.nvidia.com/assets/events/GDC15/GEFORCE/VXGI_Dynamic_Global_Illumination_GDC15.pdf" target="_blank">NVIDIA VXGI)</a>. In this step, the scene geometry is converted to a map which encodes the opacity of space with voxels. If a cube matches a complete voxel, it will produce a fully opaque voxel. But after downsampling, the opacity is reduced to 50%. Each next level of downsampling reduces the previous level to half, like the textures in the mipmap.</p>

                    <p>The voxelization process starts by choosing the projection plane in order to maximize the number of fragments generated during rasterization (<a href="http://www4.di.uminho.pt/~arf/supervision/DanielGomesVoxelRendering.pdf" target="_blank">Daniel Gomes et al, 2015</a>). However, the rasterization is performed in Multisample Anti Aliasing mode (MSAA) in order to produce multiple samples for the rasterized triangles.</p>
                    <br>
                    <center>
                    	<img class="img-responsive" src="img/MSAA.png" width="50%" height="50%" alt="">Voxelization using MSAA. <i>Source:<a href="http://on-demand.gputechconf.com/siggraph/2014/presentation/SG4114-Practical-Real-Time-Voxel-Based-Global-Illumination-Current-GPUs.pdf" target="_blank"> NVIDIA</a></i>
					</center>
					<br>
					<p>Then the depth coordinate is computed for each sample and reprojected into the other two planes.</p>
                    <br>
                    <center>
                    	<img class="img-responsive" src="img/MSAA2.png" width="50%" height="50%" alt="">Reprojection of the MSAA samples into the other two projection planes. <i>Source:<a href="http://on-demand.gputechconf.com/siggraph/2014/presentation/SG4114-Practical-Real-Time-Voxel-Based-Global-Illumination-Current-GPUs.pdf" target="_blank"> NVIDIA</a></i>
					</center>
					<br>
					<p>Finally, a bit count function is used in order to convert the coverage masks obtained by MSAA to an opacity value.</p>
                </div>


                <h2 class="articleSubTitle" onclick="hide('emittance')">Emittance Voxelization</h2>

                <div id="emittance"  style="display:none">
                    <p>In this pass it is used the opacity values calculated before to determinate the amount of light that geometry in their volume reflects or emits in all directions.</p>
                    <p>Starts by selecting the projection plane and rasterize the triangle. After that, the approximate light intensity for each voxel is computed. It can project the intensity to 3 or 6 directions. Finally, the directional intensities are accumulated for all rasterized triangles.
                    <p>Objects can change their brightness abruptly if they move, due to alterations to te number of covered  samples(small objects or large voxels in the coarse clipmap levels) (<a href="http://on-demand.gputechconf.com/siggraph/2014/presentation/SG4114-Practical-Real-Time-Voxel-Based-Global-Illumination-Current-GPUs.pdf" target="_blank">NVIDIA</a>). To solve this problem, supersampling is used.</p>
                    <br>
                    <center>
                    	<img class="img-responsive" src="img/supersampling.png" width="50%" height="50%" alt="">Movements from small objects or inside large voxels. <i>Source:<a href="http://on-demand.gputechconf.com/siggraph/2014/presentation/SG4114-Practical-Real-Time-Voxel-Based-Global-Illumination-Current-GPUs.pdf" target="_blank"> NVIDIA</a></i>
					</center>
					<br>
					<p>The coverage masks are then used to generate the brightness value of the fragment and the emittance is computed with the help of a shadow map generated previously.</p>
                </div>

                 <h2 class="articleSubTitle " onclick="hide('voxelCone')">Voxel Cone Tracing</h2>

                 <div id="voxelCone" style="display:none">
                    <p>The final step is the cone tracing. This is the process that computes approximatly the surface irradiance coming from a set of directions, given a primary direction and the cone angle. This technique is described by the equation below.</p>
                    <br>
                    <center>
                    <img src="http://latex.codecogs.com/gif.latex?Irradiance = \sum{}{}Emittance_i\left(\frac{ConeFactor}{SampleSize}\right)^{2}\prod_{0}^{i}(1-Opacity_k)^{tStep * OpacityCorrectionFactor}" border="0" ><br><i>Source:</i><a href="http://developer.download.nvidia.com/assets/events/GDC15/GEFORCE/VXGI_Dynamic_Global_Illumination_GDC15.pdf" target="_blank"> <i>NVIDIA</i></a>
                        <!--img class="img-responsive" src="img/ConeTracingEquation.png" alt=""><i>Source:<a href="http://developer.download.nvidia.com/assets/events/GDC15/GEFORCE/VXGI_Dynamic_Global_Illumination_GDC15.pdf" target="_blank"> NVIDIA VXGI</a></i-->
                    </center>
                    <br>
                    <p>The cone traverse the given direction, taking samples from the emittance texture that contribute to irradiance. In order to reduce light leaking, occlusion is also calculated as the product of opacities from all the previous samples (<a href="http://developer.download.nvidia.com/assets/events/GDC15/GEFORCE/VXGI_Dynamic_Global_Illumination_GDC15.pdf" target="_blank">NVIDIA)</a>.</p>

                    <br>

                    <div class="col-sm-9" style="float:left">
                        <p style="margin-left:-15px">This step compute the diffuse and specular indirect illumination. The diffuse tracing shoots several cones from every visible pixel, into a set of directions covering the hemisphere.</p>
                    </div>
                    <div style="float:right;padding:0px">
                        <img src="img/diffuse_tracing.png" class="normalP" style="width:150px; height:100px !important" />
                    </div>

                    <br><br><br><br>

                    <div class="col-sm-9">
                        <p style="margin-left:-15px">Specular tracing shoots one cone from every visible specular surface in the reflected view direction. If the surface is rough, it is used a wider cone.</p>
                    </div>
                    <div style="float:right;padding:0px">
                        <img src="img/rough_specular.png" class="normalP" style="width:150px; height:100px !important" />
                    </div>

                    <br><br><br><br>

                    <div class="col-sm-9">
                        <p style="margin-left:-15px">For finer surface, it is used a thiner cone. Due to the low spatial resolution, it is impossible to compute mirror-like reflections similar to ray tracing algorithms.</p>
                    </div>
                    <div style="float:right;padding:0px">
                        <img src="img/finer_specular.png" class="normalP" style="width:150px; height:100px !important" />
                    </div>
                </div>
            </div>


            <div id="c" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1" style="display:none">
                <a name="c"></a>
                <h1 class="articleTitle">VXGI steps.</h1>

                This section explains the main core of NVIDIA demo and some improvements that we made. <a href="Download/VXGI Demo.zip" download>Here</a> you can download the latest version of our improved demo. You also can follow our tutorial and make your own demo in <a href="">here</a>.

                <h2 class="articleSubTitle" onclick="hide('steps1')"> STEP 1 - Create the Voxels Global Illumination Object</h2>

                <div id="steps1">

                    <p><img src="img/arrow.png" class="normalP"/>First we need to create the <i>Global Illumination Object</i> and then insert the multiples parameters that are needed in order to work.</p>

                    <p class="codeClass">HRESULT <span style="color:green">CreateVXGIObject</span>() {...}</p>

                    <p><img src="img/arrow.png" class="normalP"/>The parameters used are a instance of
                    <span style="font-family: monospace;color:#355681;"> VXGI::GIParameters</span>.</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass">VXGI::GIParameters <span style="color:red">params</span>;</p>

                    <p><img src="img/arrow.png" class="normalP"/>Using the variable <span style="color:red;font-family: monospace;">params</span> it is possible to render the interface ( <span style="font-family: monospace;color:#355681;">g_pSceneRenderer</span> instance of <span style="font-family: monospace;color:#355681;">SceneRenderer*</span> inicialized before ( <span style="font-family: monospace;color:#355681;">SceneRenderer* g_pSceneRenderer = </span><span style="font-family: monospace;color:purple;">NULL</span><span style="font-family: monospace;color:#355681;">;</span> )), with the help of the scene renderer file.</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.rendererInterface = g_pSceneRenderer-><span style="color:rgb(0, 137, 255)">GetRendererInterface()</span>;</p>

                    <p><img src="img/arrow.png" class="normalP"/><span style="font-family: monospace;color:rgb(0, 137, 255);">GetRendererInterface()</span> is a function from <i>Direct3D</i> and in VXGI is an instance of <span style="font-family: monospace;color:#355681;">VXGI::Util::IRendererInterfaceD3D11 m_RendererInterface;</span></p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass">VXGI::Util::IRendererInterfaceD3D11* <span style="color:rgb(0, 137, 255)">GetRendererInterface()</span>{</p>
                    <p style="text-align:left; margin-left:60px;margin-top:-25px;" class="codeClass"><span style="color:red">return</span> &m_RendererInterface;</p>
                    <p style="text-align:left; margin-left:50px;margin-top:-31px;" class="codeClass">}</p>

                    <p><img src="img/arrow.png" class="normalP"/>Here we can see were VXGI is doing the shader type by calling <i>Direct3D</i>.</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.shaderType = VXGI::GIParameters::ST_D3D_BYTECODE_SM50;</p>

                    <p><img src="img/arrow.png" class="normalP"/>Here it is possible to see the <i>DLL</i> that is being called:</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.d3dCompilerDLLName = <span style="color:rgb(247, 235, 129)">"d3dcompiler_47.dll"</span>;</p>

                    <p><img src="img/arrow.png" class="normalP"/>In our project we decide to give some options to the user for the inicialization of the application, in order to the user have more interaction with the application. Like the number of directions, changing to the booth <i>Emittance</i> and <i>Opacity Map</i>:</p>
                    <p><img src="img/arrow.png" style="margin-left:100px !important" class="normalP"/>Six:</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.voxelizationParamters.opacityDirectionCount = </p>
                    <p style="text-align:left; margin-left:135px;margin-top:-25px;" class="codeClass">VXGI::OpacityDirections::<span style="color:rgb(0, 137, 255)">SIX_DIMENSIONAL</span>;</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.voxelizationParamters.emittanceDirectionCount = </p>
                    <p style="text-align:left; margin-left:135px;margin-top:-25px;" class="codeClass">VXGI::EmittanceDirections::<span style="color:rgb(0, 137, 255)">SIX_DIMENSIONAL</span>;</p>

                    <p><img src="img/arrow.png" style="margin-left:100px !important" class="normalP"/>Or three:</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.voxelizationParamters.opacityDirectionCount = </p>
                    <p style="text-align:left; margin-left:135px;margin-top:-25px;" class="codeClass">VXGI::OpacityDirections::<span style="color:rgb(0, 137, 255)">THREE_DIMENSIONAL</span>;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.voxelizationParamters.emittanceDirectionCount = </p>
                    <p style="text-align:left; margin-left:135px;margin-top:-25px;" class="codeClass">VXGI::EmittanceDirections::<span style="color:rgb(0, 137, 255)">THREE_DIMENSIONAL</span>;</p>

                    <p><img src="img/arrow.png" class="normalP"/>Besides that it is possible to change the size of the Clipmap and it is important to reference that the bigger the Clipmap value, the lower it will be the size of each voxel, resulting in a better visual aspect but the performance will decrease. This variable variates between 16 and 256:</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.voxelizationParamters.mapSize = (unsigned)ClipSize;</p>

                    <p><img src="img/arrow.png" class="normalP"/>Next we need to disable the scatter light injection. Why? Because we only want to use the light from the voxelization.</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.voxelizationParamters.maxScatterIterations = <span style="color:purple">0</span>;</p>

                    <p><img src="img/arrow.png" class="normalP"/>In the bellow code it is possible to see that VXGI send error messages in case something went wrong. If it was in the creation of the global illumination object:</p>


                    <p style="text-align:left; margin-left:50px;" class="codeClass">if(<span style="color:rgb(0, 137, 255)">VXGI_FAILED</span>(<span style="color:rgb(0, 137, 255)">VFX_VXGI_CreateGIObject</span>(params, &g_pGI))){</p>
                    <p style="text-align:left; margin-left:60px;margin-top:-25px;" class="codeClass"><span style="color:rgb(0, 137, 255)">MessageBoxA</span>(g_DeviceManager-><span style="color:rgb(0, 137, 255)">GetHWND()</span>,</p>
                    <p style="text-align:left; margin-left:195px;margin-top:-25px;" class="codeClass"><span style="color:rgb(247, 235, 129)">"Failed to create a VXGI object."</span>,</p>
                    <p style="text-align:left; margin-left:195px;margin-top:-25px;" class="codeClass"><span style="color:rgb(247, 235, 129)">"VXGI Sample"</span>, MB_ICONERROR);</p>
                    <p style="text-align:left; margin-left:60px;margin-top:-25px;" class="codeClass"><span style="color:red">return</span> E_FAIL;</p>
                    <p style="text-align:left; margin-left:50px;margin-top:-31px;" class="codeClass">}</p>


                    <p><img src="img/arrow.png" class="normalP"/>If it was in the creation of the global illumination tracer:</p>


                    <p style="text-align:left; margin-left:50px;" class="codeClass">if(<span style="color:rgb(0, 137, 255)">VXGI_FAILED</span>(g_pGI-><span style="color:rgb(0, 137, 255)">createNewTracer</span>(params, &g_pGI))){</p>
                    <p style="text-align:left; margin-left:60px;margin-top:-25px;" class="codeClass"><span style="color:rgb(0, 137, 255)">MessageBoxA</span>(g_DeviceManager-><span style="color:rgb(0, 137, 255)">GetHWND()</span>,</p>
                    <p style="text-align:left; margin-left:195px;margin-top:-25px;" class="codeClass"><span style="color:rgb(247, 235, 129)">"Failed to create a VXGI tracer."</span>,</p>
                    <p style="text-align:left; margin-left:195px;margin-top:-25px;" class="codeClass"><span style="color:rgb(247, 235, 129)">"VXGI Sample"</span>, MB_ICONERROR);</p>
                    <p style="text-align:left; margin-left:60px;margin-top:-25px;" class="codeClass"><span style="color:red">return</span> E_FAIL;</p>
                    <p style="text-align:left; margin-left:50px;margin-top:-31px;" class="codeClass">}</p>


                    <p><img src="img/arrow.png" class="normalP"/>Otherwise it will create the Global Illumination Object and the Global Illumination Tracer.</p>
                </div>

                <h2 class="articleSubTitle" onclick="hide('steps2')"> STEP 2 - Create Voxelization Geometry and Pixel Shaders</h2>

                <div id="steps2" style="display:none">

                    <p><img src="img/arrow.png" class="normalP"/>Next we need to create the voxelization on the geometry shader from the vertex shader. This is made on the <span style="color:rgb(0, 137, 255)">SceneRenderer</span>, unlike the previous step that was performed on the <span style="color:rgb(0, 137, 255)">Main</span> file. This voxelization (in the geometry shader) is made by calling:</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass">g_pGI-><span style="color:rgb(0, 137, 255)">createVoxelizationGeometryShaderFromVS</span></p>
                    <p style="text-align:left; margin-left:120px;margin-top:-25px;" class="codeClass">(&m_pVoxelizationGS, g_DefaultVS, sizeof(g_DefaultVS))...</p>

                    <p><img src="img/arrow.png" class="normalP"/>But there are other method to make this:</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass">g_pGI-><span style="color:rgb(0, 137, 255)">createVoxelizationGeometryShaderFromDS</span></p>
                    <p style="text-align:left; margin-left:120px;margin-top:-25px;" class="codeClass">(&m_pVoxelizationGS, g_DefaultVS, sizeof(g_DefaultVS))...</p>

                    <p><img src="img/arrow.png" class="normalP"/>After this, we need to do the voxelization on the pixel shader and like the case above there are two ways to do it:</p>

                    <p><img src="img/arrow.png" style="margin-left:100px;" class="normalP"/>Advanced:</p>

                    <p style="text-align:left; margin-left:150px; margin-top:-15px;" class="codeClass">g_pGI-><span style="color:rgb(0, 137, 255)">createVoxelizationPixelShader</span></p>
                    <p style="text-align:left; margin-left:220px;margin-top:-25px;" class="codeClass">(&m_pVoxelizationPS, desc)...</p>

                    <p><img src="img/arrow.png" style="margin-left:100px;" class="normalP"/>Default:</p>

                    <p style="text-align:left; margin-left:150px; margin-top:-15px;" class="codeClass">g_pGI-><span style="color:rgb(0, 137, 255)">createVoxelizationDefaultPixelShader</span></p>
                    <p style="text-align:left; margin-left:220px;margin-top:-25px;" class="codeClass">(&m_pVoxelizationPS, desc)...</p>

                </div>

                <h2 class="articleSubTitle" onclick="hide('steps3')"> STEP 3 - Scene Voxelization</h2>

                <div id="steps3" style="display:none">

                    <p><img src="img/arrow.png" class="normalP"/>The next step it is to voxelize the scene. In order to do so there are a few calls there are needed, besides that it is important to reference that this calls are made inside the <u><i>render</i></u> function in the <span style="color:rgb(0, 137, 255)">Main</span> file.</p>
                    <p><img src="img/arrow.png" class="normalP"/>First we need to attribute some values to the parameter <span style="color:red;font-family: monospace;">params</span>.</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass">VXGI::LightDesc light = g_pSceneRenderer-><span style="color:rgb(0, 137, 255)">GetLightDesc</span>();</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass">VXGI::UpdateVoxelizationParameters <span style="color:red">params</span>;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.clipmapAnchor = VXGI::Vector3f(centerPt.m128_f32);</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.giRange = g_fClipmapRange;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.lights = &light;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">params</span>.lightCount = 1;</p>

                    <p><img src="img/arrow.png" class="normalP"/>Next we need to create two booleans initialized with <span style="color:purple;font-family: monospace;">false</span> to be used further in the code:</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:rgb(0, 137, 255)">bool</span> performOpacityVoxelization = <span style="color:purple">false</span>;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:rgb(0, 137, 255)">bool</span> performEmittanceVoxelization = <span style="color:purple">false</span>;</p>

                    <p><img src="img/arrow.png" class="normalP"/>Next we need to call the function <span style="font-family: monospace;color:rgb(0, 137, 255)">prepareForOpacityVoxelization()</span> passing the booleans created before as arguments:</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass">g_pGI-><span style="color:rgb(0, 137, 255)">prepareForOpacityVoxelization</span>( params,</p>
                    <p style="text-align:left; margin-left:265px; margin-top:-25px;" class="codeClass">performOpacityVoxelization,</p>
                    <p style="text-align:left; margin-left:265px; margin-top:-25px;" class="codeClass">performEmittanceVoxelization);</p>

                    <p><img src="img/arrow.png" class="normalP"/>After this we need to check the value of the previous booleans:</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">if</span>(performOpacityVoxelization || performEmittanceVoxelization){ ... }</p>

                    <p><img src="img/arrow.png" class="normalP"/>If any of them has the flag with value <span style="color:purple;font-family: monospace;">true</span> we continue. Next we need to get the invalidated regions. This is a set of world-space boxes that contains some geometry that changed since the previous frame. This is important because we only need to voxelize the things that change or the newest parts of the scene that we now can voxelize.</p>
                    <p><img src="img/arrow.png" class="normalP"/>If this occurs then we can perform the <u><i>Emittance</u></i> and/or the <u><i>Opacity</u></i> voxelization steps, according the value of the previous booleans:</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">if</span>(performOpacityVoxelization)</p>
                    <p style="text-align:left; margin-left:150px; margin-top:-25px" class="codeClass">g_pSceneRenderer-><span style="color:rgb(0, 137, 255)">RenderSceneCommon</span>(g_pGI , regions,</p>
                    <p style="text-align:left; margin-left:250px; margin-top:-25px" class="codeClass">numRegions, voxelizationMatrix, <span style="color:purple">NULL</span>, <span style="color:purple">true</span>);</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">if</span>(performEmittanceVoxelization) {</p>
                    <p style="text-align:left; margin-left:150px; margin-top:-25px" class="codeClass">g_pGI-><span style="color:rgb(0, 137, 255)">prepareForEmittanceVoxelization</span>();</p>
                    <p style="text-align:left; margin-left:150px; margin-top:-25px" class="codeClass">g_pSceneRenderer-><span style="color:rgb(0, 137, 255)">RenderSceneCommon</span>(g_pGI , <span style="color:purple">NULL</span>, <span style="color:purple">0</span></p>
                    <p style="text-align:left; margin-left:250px; margin-top:-25px" class="codeClass">voxelizationMatrix, <span style="color:purple">NULL</span>, <span style="color:purple">true</span>);</p>
                    <p style="text-align:left; margin-left:50px;margin-top:-30px;" class="codeClass">}</p>

                    <p><img src="img/arrow.png" class="normalP"/>And finally we only need to finalize the voxelization process:</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass">g_pGI-><span style="color:rgb(0, 137, 255)">finalizeVoxelization</span>();</p>

                </div>

                <h2 class="articleSubTitle" onclick="hide('steps4')"> STEP 4 - Cone Tracing</h2>

                <div id="steps4" style="display:none">

                    <p><img src="img/arrow.png" class="normalP"/>First we need to attribute some values to the parameters <span style="color:red;font-family: monospace;">diffuseParams</span> and <span style="color:red;font-family: monospace;">specularParams</span>:</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass">VXGI::DiffuseTracingParameters <span style="color:red">diffuseParams</span>;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass">VXGI::SpecularTracingParameters <span style="color:red">specularParams</span>;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">diffuseParams</span>.numCones = g_numcones;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">diffuseParams</span>.tracingSparsity = g_tracingSparsity;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">diffuseParams</span>.enableConeRotation = g_cone_rotation;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">diffuseParams</span>.irradianceScale = g_fDiffuseScale;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">specularParams</span>.irradianceScale = g_fSpecularScale;</p>
                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">specularParams</span>.filter = VXGI::SpecularTracingParameters::FILTER_NONE;</p>

                    <p><img src="img/arrow.png" class="normalP"/>This parameter adds occluded directional ambient color to the scene. It is an array with six positions for every direction of each voxel, ordered as follows: X+, X-, Y+, Y-, Z+, Z-.</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">for</span>(n = <span style="color:purple">0</span>; n < <span style="color:purple">6</span>; n++) {</p>
                    
                    <p style="text-align:left; margin-left:100px;margin-top:-25px;" class="codeClass">diffuseParams.ambientColors[n] = ambientColor;</p>

                    <p><img src="img/arrow.png" class="normalP"/>Case the <span style="font-family: monospace;color:#355681;">g_fDiffuseScale</span> variable it is greater then zero the diffuse component will be computed:</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">if</span>(g_fDiffuseScale > <span style="color:purple">0</span>) {</p>
                    <p style="text-align:left; margin-left:100px;margin-top:-25px;" class="codeClass">g_pGITracer-><span style="color:rgb(0, 137, 255)">computeDiffuseChannel</span>(diffuseParams,</p>
                    <p style="text-align:left; margin-left:250px;margin-top:-25px;" class="codeClass">indirectDiffuse, inputBuffers);</p>

                    <p><img src="img/arrow.png" class="normalP"/>Case the <span style="font-family: monospace;color:#355681;">g_fSpecularScale</span> variable it is greater then zero the specular component will be computed:</p>

                    <p style="text-align:left; margin-left:50px;" class="codeClass"><span style="color:red">if</span>(g_fSpecularScale > <span style="color:purple">0</span>) {</p>
                    <p style="text-align:left; margin-left:100px;margin-top:-25px;" class="codeClass">g_pGITracer-><span style="color:rgb(0, 137, 255)">computeSpecularChannel</span>(specularParams,</p>
                    <p style="text-align:left; margin-left:250px;margin-top:-25px;" class="codeClass">indirectDiffuse, inputBuffers);</p>


                </div>
            </div>
            
            <div id="d" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1" style="display:none">
                <a name="d"></a>
                <h1 class="articleTitle">Application & Tutorial</h1>
                
                <p>This section has the purpose of helping the users to test the improved demo that we made based on NVIDIA's demo. It contains a detailed tutorial to ease the interation between the user and the interface.</p>

                <p>If you want to try the demo for yourself you can download it  <a href="Download/VXGI Demo.zip" download>here</a>.</p>
                
                <h2 class="articleSubTitle" onclick="hide('before')">Before Starting the Application</h2>
                
                <div id="before">
                    <ol type="1">
                        <li>Open Terminal in "bin" folder.</li>
                        <li>Execute GFSDK_VXGI_Sample_GlobalIllumination_x64.exe along the following parameters:</li>
                        <ul>
                            <li>Name of the model in folder "media"</li>
                            <li>Number of Directions (3 or 6 directions)</li>
                            <li>Size of the Clipmap</li>
                        </ul>
                    </ol>
                    Example:
                    <img class="img-responsive" src="img/tutorial/terminal.png" alt="">
                    <br/>
                    <p>We only provided the Sponza model in our link above, but you can download other famous models like Rungholt and Power Plant <a href="http://graphics.cs.williams.edu/data/meshes.xml">here</a>.</p>
                </div>
                
                <h2 class="articleSubTitle " onclick="hide('after')">After Starting the Application</h2>
                
                <div id="after" style="display:none">
                    <p class="tutorialApp"><img src="img/arrow.png" class="normalP"/>After starting the application, the object is shown with the respectively frames per second. A simple interface is also displayed in the upper-left corner with modifiable parameters that change the scene appearence in real time.</p>
                    
                    <div>
                        <center>
                            <div class="image">
                                <a rel="gallery" title="Interface" href="img/tutorial/initialSettings.jpg">
                                    <img class="img-responsive" src="img/tutorial/initialSettings.jpg"/>
                                </a>
                                <i class="legend">Interface</i>
                            </div>
                        </center>
                    </div>
                    
                    <br><br>
                        
                    <p class="tutorialApp"><img src="img/arrow.png" class="normalP"/>To view the voxelization process you can alternate the debug options by pressing 'g'. As you can see below, the scene is first voxelized and after that is performed the emittance voxelization to emit and reflect the light injected directly in the scene.</p>
                        
                    <table align="center" style="width:100%">
                        <tr>
                            <td align="center" style="width:33%">
                                <div class="image" >
                                    <a rel="gallery" title="Main Scene" href="img/tutorial/main.jpg">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/main.jpg"/>
                                    </a>
                                </div>
                            </td>
                            <td align="center" style="width:33%">
                                <div class="image">
                                    <a rel="gallery" title="Opacity Voxelization" href="img/tutorial/opacity.png">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/opacity.png"/>
                                    </a>
                                </div>
                            </td>
                            <td align="center" style="width:33%">
                                <div class="image">
                                    <a rel="gallery" title="Emmitance Voxelization" href="img/tutorial/emmitance.png">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/emmitance.png"/>
                                    </a>
                                </div>
                            </td>
                        </tr>
                        <tr>
                            <td align="center"><i class="legend">Main Scene</i></td>
                            <td align="center"><i class="legend">Opacity Voxelization</i></td>
                            <td align="center"><i class="legend">Emittance Voxelization</i></td>
                        </tr>
                    </table>
                        
                    <br><br>
                            
                    <p class="tutorialApp"><img src="img/arrow.png" class="normalP"/>Also is possible to switch on and off the global illumination of the scene by clicking on the <i>Enable GI</i> button. The results are shown on the images below.</p>
                            
                    <table style="width:100%">
                        <tr>
                            <td align="center" style="width:50%">
                                <div class="image">
                                    <a rel="gallery" title="No Global Illumination" href="img/tutorial/NoGI.jpg">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/NoGI.jpg"/>
                                    </a>
                            </td>
                            <td align="center" style="width:50%">
                                <div class="image">
                                    <a rel="gallery" title="With Global Illumination" href="img/tutorial/GI.jpg">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/GI.jpg"/>
                                    </a>
                            </td>
                        </tr>
                        <tr>
                            <td align="center"><i class="legend">No Global Illumination</i></td>
                            <td align="center"><i class="legend">With Global Illumination</i></td>
                        </tr>
                    </table>
                    
                    <br><br>
                                
                    <p class="tutorialApp"><img src="img/arrow.png" class="normalP"/>The objects that are not directly illuminated do not have any color. They are only visible due to the ambient color. Disabling this parameter(<i>Ambient Scale</i> value is 0.0) the non-illuminated sections are black. By enabling the global illumination are now visible due to the indirect diffuse color and specular light.</p>
                                
                    <table style="width:100%;display:block;">
                        <tr>
                            <td align="center" style="width:50%">
                                <div class="image">
                                    <a rel="gallery" title="No Global Illumination" href="img/tutorial/NoAmbientNoGI.png">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/NoAmbientNoGI.png"/>
                                    </a>
                                </div>
                            </td>
                            <td align="center" style="width:50%">
                                <div class="image">
                                    <a rel="gallery" title="With Global Illumination" href="img/tutorial/NoAmbientGI.jpg">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/NoAmbientGI.jpg"/>
                                    </a>
                                </div>
                            </td>
                        </tr>
                        <tr>
                            <td align="center"><i class="legend">No Global Illumination</i></td>
                            <td align="center"><i class="legend">With Global Illumination</i></td>
                        </tr>
                    </table>
                                
                    <br><br>
                                    
                    <p class="tutorialApp"><img src="img/arrow.png" class="normalP"/>The scene may suffer from banding issues. To reduce this effect we can use the <i>Cone Rotation</i> parameter. It performs a random per-pixel rotation of the diffuse cone set. This results on a better visual result, but costs some performance.</p>
                                    
                    <table style="width:100%">
                        <tr>
                            <td align="center" style="width:50%">
                                <div class="image">
                                    <a rel="gallery" title="No Cone Rotation" href="img/tutorial/NoConeRotation.jpg">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/NoConeRotation.jpg"/>
                                    </a>
                                </div>
                            </td>
                            <td align="center" style="width:50%">
                                <div class="image">
                                    <a rel="gallery" title="With Cone Rotation" href="img/tutorial/ConeRotation.jpg">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/ConeRotation.jpg"/>
                                    </a>
                                </div>
                            </td>
                        </tr>
                        <tr>
                            <td align="center"><i class="legend">No Cone Rotation</i></td>
                            <td align="center"><i class="legend">With Cone Rotation</i></td>
                        </tr>
                    </table>
                                    
                    <br><br>
                                        
                    <p class="tutorialApp"><img src="img/arrow.png" class="normalP"/>By enable and disable the shading parameters, like the diffuse color or specularity, we can see different results on the desired scene.</p>
                    
                    <table style="width:100%">
                        <tr>
                            <td align="center" style="width:33%">
                                <div class="image">
                                    <a rel="gallery" title="Only Direct Light" href="img/tutorial/Nothing.png">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/Nothing.png"/>
                                    </a>
                                </div>
                            </td>
                            <td align="center" style="width:33%">
                                <div class="image">
                                    <a rel="gallery" title="Ambient Color Only" href="img/tutorial/AmbientOnly.jpg">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/AmbientOnly.jpg"/>
                                    </a>
                                </div>
                            </td>
                            <td align="center" style="width:33%">
                                <div class="image">
                                    <a rel="gallery" title="Diffuse Color Only" href="img/tutorial/DiffuseOnly.jpg">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/DiffuseOnly.jpg"/>
                                    </a>
                                </div>
                            </td>
                        </tr>
                        <tr>
                            <td align="center"><i class="legend">Only Direct Light</i></td>
                            <td align="center"><i class="legend">Ambient Color Only</i></td>
                            <td align="center"><i class="legend">Diffuse Color Only</i></td>
                        </tr>
                    </table>
                    
                    <br><br>
                                            
                    <table style="width:100%">
                        <tr>
                            <td align="center">
                                <div class="image">
                                    <a rel="gallery" title="Specular Light Only" href="img/tutorial/SpecularOnly.jpg">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/SpecularOnly.jpg"/>
                                    </a>
                                </div>
                            </td>
                            <td align="center">
                                <div class="image">
                                    <a rel="gallery" title="All parameters Enabled" href="img/tutorial/EverythingEnabled.jpg">
                                        <img class="img-responsive col-lg-12" src="img/tutorial/EverythingEnabled.jpg"/>
                                    </a>
                                </div>
                            </td>
                        </tr>
                        <tr>
                            <td align="center"><i class="legend">Specular Light Only</i></td>
                            <td align="center"><i class="legend">All parameters Enabled</i></td>
                        </tr>
                    </table>
                    
                    <br> 

                </div>
            </div>
            
        </div>

        <br/>

        <div id="btnDown" style="margin-right:219px">
            <a class="btn btn-primary btn-lg gradient" style="float:right" href="index.html"><i style="padding-right:12px; padding-left:12px" class="fa fa-arrow-circle-left">&nbsp;&nbsp;back</i></a>
        </div>
    </div>

    <br><br><hr><br><br>

    
    <div class="banner">
        
        <div class="container">

            <div class="row">
                <div class="col-lg-12">
                    <h2 style="text-align:center">VXGI : Voxel Global Illumination</h2>
                </div>
            </div>

        </div>

    </div>

    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <p class="copyright text-muted small">Universidade do Minho, Projecto Integrado - VXGI</p>
                </div>
            </div>
        </div>
    </footer>

</body>

</html>
